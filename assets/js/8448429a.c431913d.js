"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[8268],{4137:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return c}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),c=o,f=m["".concat(l,".").concat(c)]||m[c]||d[c]||r;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function c(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5097:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return u},default:function(){return m}});var a=n(7462),o=n(3366),r=(n(7294),n(4137)),i=["components"],s={title:"Protobuf Integration",sidebar_label:"Protobuf Integration",slug:"/metadata-integration/java/datahub-protobuf",custom_edit_url:"https://github.com/linkedin/datahub/blob/master/metadata-integration/java/datahub-protobuf/README.md"},l="Protobuf Integration",p={unversionedId:"metadata-integration/java/datahub-protobuf/README",id:"metadata-integration/java/datahub-protobuf/README",isDocsHomePage:!1,title:"Protobuf Integration",description:"This module is designed to be used with the Java Emitter, the input is a compiled protobuf binary *.protoc files",source:"@site/genDocs/metadata-integration/java/datahub-protobuf/README.md",sourceDirName:"metadata-integration/java/datahub-protobuf",slug:"/metadata-integration/java/datahub-protobuf",permalink:"/docs/metadata-integration/java/datahub-protobuf",editUrl:"https://github.com/linkedin/datahub/blob/master/metadata-integration/java/datahub-protobuf/README.md",tags:[],version:"current",frontMatter:{title:"Protobuf Integration",sidebar_label:"Protobuf Integration",slug:"/metadata-integration/java/datahub-protobuf",custom_edit_url:"https://github.com/linkedin/datahub/blob/master/metadata-integration/java/datahub-protobuf/README.md"},sidebar:"overviewSidebar",previous:{title:"Data Quality with Great Expectations",permalink:"/docs/metadata-ingestion/integration_docs/great-expectations"},next:{title:"Introduction to Scheduling Metadata Ingestion",permalink:"/docs/metadata-ingestion/schedule_docs/intro"}},u=[{value:"Supported Features",id:"supported-features",children:[],level:2},{value:"Usage",id:"usage",children:[{value:"Protobuf Compile Options",id:"protobuf-compile-options",children:[],level:3},{value:"Code Example",id:"code-example",children:[],level:3},{value:"Protobuf Extensions",id:"protobuf-extensions",children:[{value:"meta.proto",id:"metaproto",children:[],level:4},{value:"FieldOptions",id:"fieldoptions",children:[],level:4},{value:"MessageOptions",id:"messageoptions",children:[],level:4}],level:3}],level:2}],d={toc:u};function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"protobuf-integration"},"Protobuf Integration"),(0,r.kt)("p",null,"This module is designed to be used with the Java Emitter, the input is a compiled protobuf binary ",(0,r.kt)("inlineCode",{parentName:"p"},"*.protoc")," files\nand optionally the corresponding ",(0,r.kt)("inlineCode",{parentName:"p"},"*.proto")," source code. In addition, you can supply the root message in cases\nwhere a single protobuf source file includes multiple non-nested messages."),(0,r.kt)("h2",{id:"supported-features"},"Supported Features"),(0,r.kt)("p",null,"The following protobuf features are supported and are translated into descriptions, tags, properties and terms on a\ndataset."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"* C++/C style code comments on Messages and Fields\n* Nested Types\n* Scalar Values\n* Well Known Type Wrappers (i.e. DoubleValue, FloatValue, StringValue)\n* Enumerations\n* Oneof\n* Maps\n* Extensions\n* Web links\n* Parsing of GitHub team names and slack channel references\n")),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("h3",{id:"protobuf-compile-options"},"Protobuf Compile Options"),(0,r.kt)("p",null,"In order to support parsing comments the following option flags should be used during ",(0,r.kt)("inlineCode",{parentName:"p"},"protoc")," compilation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"protoc --include_imports --include_source_info --descriptor_set_out=MyProto.protoc MyProto.proto\n")),(0,r.kt)("h3",{id:"code-example"},"Code Example"),(0,r.kt)("p",null,"Given an input stream of the ",(0,r.kt)("inlineCode",{parentName:"p"},"protoc")," binary and the emitter the minimal code is shown below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import com.linkedin.common.FabricType;\nimport com.linkedin.common.AuditStamp;\nimport com.linkedin.common.urn.CorpuserUrn;\nimport datahub.client.rest.RestEmitter;\nimport datahub.protobuf.ProtobufDataset;\n\nRestEmitter emitter;\nInputStream protocInputStream;\n\nAuditStamp auditStamp = new AuditStamp()\n    .setTime(System.currentTimeMillis())\n    .setActor(new CorpuserUrn("datahub"));\n\nProtobufDataset dataset = ProtobufDataset.builder()\n    .setDataPlatformUrn(new DataPlatformUrn("kafka"))\n    .setProtocIn(protocInputStream)\n    .setAuditStamp(auditStamp)\n    .setFabricType(FabricType.DEV)\n    .build();\n\ndataset.getAllMetadataChangeProposals().forEach(mcpw -> emitter.emit(mcpw, null).get());\n')),(0,r.kt)("p",null,"Additionally, the raw protobuf source can be included as well as information to allow parsing of additional\nreferences to GitHub and Slack in the source code comments."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'ProtobufDataset dataset = ProtobufDataset.builder()\n    .setDataPlatformUrn(new DataPlatformUrn("kafka"))\n    .setSchema(" my raw protobuf schema ")\n    .setProtocIn(protocInputStream)\n    .setAuditStamp(auditStamp)\n    .setFabricType(FabricType.DEV)\n    .setGithubOrganization("myOrg")\n    .setSlackTeamId("SLACK123")\n    .build();\n')),(0,r.kt)("h3",{id:"protobuf-extensions"},"Protobuf Extensions"),(0,r.kt)("p",null,"In order to extract even more metadata from the protobuf schema we can extend the FieldOptions and MessageOptions\nto be able to annotate Messages and Fields with arbitrary information. This information can then be emitted\nas DataHub primary key information, tags, glossary terms or properties on the dataset."),(0,r.kt)("p",null,"An annotated protobuf schema would look like the following, except for the ",(0,r.kt)("inlineCode",{parentName:"p"},"is_primary_key")," all\nannotations are configurable for individual needs."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Note"),": Extending FieldOptions and MessageOptions does not change the messages themselves. The metadata is not included\nin messages being sent over the wire."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-protobuf"},'syntax = "proto3";\nimport "meta.proto";\n\nmessage Department {\n    int32 id = 1 [(meta.fld.is_primary_key) = true];\n    string name = 2;\n}\n\nmessage Person {\n    option(meta.msg.type) = ENTITY;\n    option(meta.msg.classification_enum) = HighlyConfidential;\n    option(meta.msg.team) = "TeamB";\n    option(meta.msg.bool_feature) = true;\n    option(meta.msg.alert_channel) = "#alerts";\n\n    string name = 1 [(meta.fld.classification) = "Classification.HighlyConfidential"];\n\n    int32 id = 2\n    [(meta.fld.is_primary_key) = true];\n\n    string email = 3\n    [(meta.fld.classification_enum) = Confidential];\n    \n    Department dept = 4;\n    \n    string test_coverage = 5\n    [(meta.fld.product_type_bool) = true, (meta.fld.product_type) = "my type", (meta.fld.product_type_enum) = EVENT];\n}\n')),(0,r.kt)("h4",{id:"metaproto"},"meta.proto"),(0,r.kt)("p",null,"In order to use the annotations above, create a proto file called ",(0,r.kt)("inlineCode",{parentName:"p"},"meta.proto"),". Feel free to customize the kinds of\nmetadata and how it is emitted to DataHub for your use cases."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-protobuf"},'syntax = "proto3";\npackage meta;\n\nimport "google/protobuf/descriptor.proto";\n\n/*\n   This is assigned to metadata fields. It describes how the metadata field should be represented\n   in DataHub. This enum must be used in the `meta` package. Multiple can be used for the same\n   metadata annotation. This allows a single piece of information to be captured in DataHub\n   as a property, tag and/or term.\n\n   Tags can be strings, enums, or booleans\n   Terms can be strings or enums\n   Properties should be strings\n\n*/\nenum DataHubMetadataType {\n  PROPERTY = 0; // Datahub Custom Property\n  TAG      = 1; // Datahub Tag\n  TERM     = 2; // Datahub Term\n}\n\n/*\n   Example below: The following is not required for annotation processing. This is an example\n   of creating an annotation using an enum.\n */\n\nenum MetaEnumExample {\n  UNKNOWN = 0;\n  ENTITY = 1;\n  EVENT = 2;\n}\n\n// Assuming Glossary Term defined from bootstrap example\nenum Classification {\n  HighlyConfidential = 0;\n  Confidential = 1;\n  Sensitive = 2;\n}\n')),(0,r.kt)("h4",{id:"fieldoptions"},"FieldOptions"),(0,r.kt)("p",null,"Define possible annotations on fields and how they are exported to DataHub."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-protobuf"},"\nmessage fld {\n  extend google.protobuf.FieldOptions {\n    // Required: Mark option field with how to export to DataHub in one or more places.\n    repeated meta.DataHubMetadataType type = 6000;\n\n    /*\n       Examples below: The following is not required for annotation processing.\n     */\n\n    // Set true if the field is a primary key. This works for any boolean with `primary_key` in it.\n    bool is_primary_key = 6010;\n\n    // Extract classification field option as a Term, either works\n    string classification = 6001 [(meta.fld.type) = TERM];\n    meta.Classification classification_enum = 6002 [(meta.fld.type) = TERM];\n\n    // Expose this option as a tag on the field.\n    string product_type = 70004 [(meta.fld.type) = TAG];\n    bool product_type_bool = 70005 [(meta.fld.type) = TAG];\n    meta.MetaEnumExample product_type_enum = 70006 [(meta.fld.type) = TAG];\n  }\n}\n")),(0,r.kt)("h4",{id:"messageoptions"},"MessageOptions"),(0,r.kt)("p",null,"Define possible annotations on messages and how they are exported to DataHub."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-protobuf"},"\nmessage msg {\n  extend google.protobuf.MessageOptions {\n    /*\n       Examples below: The following is not required for annotation processing.\n     */\n\n    // Place the classification term at the Message/Dataset level, either string or enum is supported\n    string classification = 4000 [(meta.fld.type) = TERM, (meta.fld.type) = PROPERTY];\n    meta.Classification classification_enum = 4001 [(meta.fld.type) = TERM, (meta.fld.type) = PROPERTY];\n\n    // Attach these Message/Dataset options as a tag and property.\n    string product = 5001 [(meta.fld.type) = TAG, (meta.fld.type) = PROPERTY];\n    string project = 5002 [(meta.fld.type) = TAG, (meta.fld.type) = PROPERTY];\n    string team = 5003 [(meta.fld.type) = TAG, (meta.fld.type) = PROPERTY];\n\n    string domain = 60003 [(meta.fld.type) = TAG, (meta.fld.type) = PROPERTY];\n    meta.MetaEnumExample type = 60004 [(meta.fld.type) = TAG, (meta.fld.type) = PROPERTY];\n    bool bool_feature = 60005 [(meta.fld.type) = TAG];\n    string alert_channel = 60007 [(meta.fld.type) = PROPERTY];\n  }\n}\n")))}m.isMDXComponent=!0}}]);