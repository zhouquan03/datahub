"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[2501],{4137:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return g}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=u(n),g=i,h=c["".concat(s,".").concat(g)]||c[g]||p[g]||r;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},7182:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return d},default:function(){return c}});var a=n(7462),i=n(3366),r=(n(7294),n(4137)),o=["components"],l={title:"Stateful Ingestion",sidebar_label:"Stateful Ingestion",slug:"/metadata-ingestion/source_docs/stateful_ingestion",custom_edit_url:"https://github.com/linkedin/datahub/blob/master/metadata-ingestion/source_docs/stateful_ingestion.md"},s="Stateful Ingestion",u={unversionedId:"metadata-ingestion/source_docs/stateful_ingestion",id:"metadata-ingestion/source_docs/stateful_ingestion",isDocsHomePage:!1,title:"Stateful Ingestion",description:"The stateful ingestion feature enables sources to be configured to save custom checkpoint states from their",source:"@site/genDocs/metadata-ingestion/source_docs/stateful_ingestion.md",sourceDirName:"metadata-ingestion/source_docs",slug:"/metadata-ingestion/source_docs/stateful_ingestion",permalink:"/docs/metadata-ingestion/source_docs/stateful_ingestion",editUrl:"https://github.com/linkedin/datahub/blob/master/metadata-ingestion/source_docs/stateful_ingestion.md",tags:[],version:"current",frontMatter:{title:"Stateful Ingestion",sidebar_label:"Stateful Ingestion",slug:"/metadata-ingestion/source_docs/stateful_ingestion",custom_edit_url:"https://github.com/linkedin/datahub/blob/master/metadata-ingestion/source_docs/stateful_ingestion.md"},sidebar:"overviewSidebar",previous:{title:"Other SQLAlchemy databases",permalink:"/docs/metadata-ingestion/source_docs/sqlalchemy"},next:{title:"Superset",permalink:"/docs/metadata-ingestion/source_docs/superset"}},d=[{value:"Config details",id:"config-details",children:[],level:2},{value:"Use-cases powered by stateful ingestion.",id:"use-cases-powered-by-stateful-ingestion",children:[{value:"Removal of stale tables and views.",id:"removal-of-stale-tables-and-views",children:[{value:"Supported sources",id:"supported-sources",children:[],level:4},{value:"Additional config details",id:"additional-config-details",children:[],level:4},{value:"Sample configuration",id:"sample-configuration",children:[],level:4}],level:3},{value:"Prevent redundant reruns for usage source.",id:"prevent-redundant-reruns-for-usage-source",children:[{value:"Supported sources",id:"supported-sources-1",children:[],level:4},{value:"Additional config details",id:"additional-config-details-1",children:[],level:4},{value:"Sample Configuration",id:"sample-configuration-1",children:[],level:4}],level:3}],level:2},{value:"The Ingestion State Provider",id:"the-ingestion-state-provider",children:[{value:"Datahub Ingestion State Provider",id:"datahub-ingestion-state-provider",children:[{value:"Config details",id:"config-details-1",children:[],level:4}],level:3}],level:2}],p={toc:d};function c(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"stateful-ingestion"},"Stateful Ingestion"),(0,r.kt)("p",null,"The stateful ingestion feature enables sources to be configured to save custom checkpoint states from their\nruns, and query these states back from subsequent runs to make decisions about the current run based on the state saved\nfrom the previous run(s) using a supported ingestion state provider. This is an explicit opt-in feature and is not enabled\nby default."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"NOTE")),": This feature requires the server to be ",(0,r.kt)("inlineCode",{parentName:"p"},"statefulIngestion")," capable. This is a feature of metadata service with version >= ",(0,r.kt)("inlineCode",{parentName:"p"},"0.8.20"),". "),(0,r.kt)("p",null,"To check if you are running a stateful ingestion capable server:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},'curl http://<datahub-gms-endpoint>/config\n\n{\nmodels: { },\nstatefulIngestionCapable: true, # <-- this should be present and true\nretention: "true",\nnoCode: "true"\n}\n')),(0,r.kt)("h2",{id:"config-details"},"Config details"),(0,r.kt)("p",null,"Note that a ",(0,r.kt)("inlineCode",{parentName:"p"},".")," is used to denote nested fields in the YAML recipe."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"source.config.stateful_ingestion.enabled")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"False"),(0,r.kt)("td",{parentName:"tr",align:null},"The type of the ingestion state provider registered with datahub.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"source.conifg.stateful_ingestion.ignore_old_state")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"False"),(0,r.kt)("td",{parentName:"tr",align:null},"If set to True, ignores the previous checkpoint state.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"source.conifg.stateful_ingestion.ignore_new_state")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"False"),(0,r.kt)("td",{parentName:"tr",align:null},"If set to True, ignores the current checkpoint state.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"source.conifg.stateful_ingestion.max_checkpoint_state_size")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"2^24 (16MB)"),(0,r.kt)("td",{parentName:"tr",align:null},"The maximum size of the checkpoint state in bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"source.conifg.stateful_ingestion.state_provider")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"The default ",(0,r.kt)("a",{parentName:"td",href:"#datahub-ingestion-state-provider"},"datahub ingestion state provider")," configuration."),(0,r.kt)("td",{parentName:"tr",align:null},"The ingestion state provider configuration.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"pipeline_name")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"The name of the ingestion pipeline the checkpoint states of various source connector job runs are saved/retrieved against via the ingestion state provider.")))),(0,r.kt)("p",null,"NOTE: If either ",(0,r.kt)("inlineCode",{parentName:"p"},"dry-run")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"preview")," mode are set, stateful ingestion will be turned off regardless of the rest of the configuration."),(0,r.kt)("h2",{id:"use-cases-powered-by-stateful-ingestion"},"Use-cases powered by stateful ingestion."),(0,r.kt)("p",null,"Following is the list of current use-cases powered by stateful ingestion in datahub."),(0,r.kt)("h3",{id:"removal-of-stale-tables-and-views"},"Removal of stale tables and views."),(0,r.kt)("p",null,"Stateful ingestion can be used to automatically soft delete the tables and views that are seen in a previous run\nbut absent in the current run (they are either deleted or no longer desired)."),(0,r.kt)("h4",{id:"supported-sources"},"Supported sources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"All sql based sources.")),(0,r.kt)("h4",{id:"additional-config-details"},"Additional config details"),(0,r.kt)("p",null,"Note that a ",(0,r.kt)("inlineCode",{parentName:"p"},".")," is used to denote nested fields in the YAML recipe."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"stateful_ingestion.remove_stale_metadata")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"True"),(0,r.kt)("td",{parentName:"tr",align:null},"Soft-deletes the tables and views that were found in the last successful run but missing in the current run with stateful_ingestion enabled.")))),(0,r.kt)("h4",{id:"sample-configuration"},"Sample configuration"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'source:\n  type: "snowflake"\n  config:\n    username: <user_name>\n    password: <password>\n    host_port: <host_port>\n    warehouse: <ware_house>\n    role: <role>\n    include_tables: True\n    include_views: True\n    # Rest of the source specific params ...\n    ## Stateful Ingestion config ##\n    stateful_ingestion:\n        enabled: True # False by default\n        remove_stale_metadata: True # default value\n        ## Default state_provider configuration ##\n        # state_provider:\n            # type: "datahub" # default value\n            # This section is needed if the pipeline-level `datahub_api` is not configured.\n            # config:  # default value\n            #    datahub_api: \n            #        server: "http://localhost:8080"\n\n# The pipeline_name is mandatory for stateful ingestion and the state is tied to this.\n# If this is changed after using with stateful ingestion, the previous state will not be available to the next run.\npipeline_name: "my_snowflake_pipeline_1"\n\n# Pipeline-level datahub_api configuration.\ndatahub_api: # Optional. But if provided, this config will be used by the "datahub" ingestion state provider.\n    server: "http://localhost:8080"\n    \nsink:\n  type: "datahub-rest"\n  config:\n    server: \'http://localhost:8080\'\n')),(0,r.kt)("h3",{id:"prevent-redundant-reruns-for-usage-source"},"Prevent redundant reruns for usage source."),(0,r.kt)("p",null,"Typically, the usage runs are configured to fetch the usage data for the previous day(or hour) for each run. Once a usage\nrun has finished, subsequent runs until the following day would be fetching the same usage data. With stateful ingestion,\nthe redundant fetches can be avoided even if the ingestion job is scheduled to run more frequently than the granularity of\nusage ingestion."),(0,r.kt)("h4",{id:"supported-sources-1"},"Supported sources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Snowflake Usage source.")),(0,r.kt)("h4",{id:"additional-config-details-1"},"Additional config details"),(0,r.kt)("p",null,"Note that a ",(0,r.kt)("inlineCode",{parentName:"p"},".")," is used to denote nested fields in the YAML recipe."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"stateful_ingestion.force_rerun")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"False"),(0,r.kt)("td",{parentName:"tr",align:null},"Custom-alias for ",(0,r.kt)("inlineCode",{parentName:"td"},"stateful_ingestion.ignore_old_state"),". Prevents a rerun for the same time window if there was a previous successful run.")))),(0,r.kt)("h4",{id:"sample-configuration-1"},"Sample Configuration"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'source:\n  type: "snowflake-usage"\n  config:\n    username: <user_name>\n    password: <password>\n    role: <role>\n    host_port: <host_port>\n    warehouse: <ware_house>\n    # Rest of the source specific params ...\n    ## Stateful Ingestion config ##\n    stateful_ingestion:\n        enabled: True # default is false\n        force_rerun: False # Specific to this source(alias for ignore_old_state), used to override default behavior if True.\n\n# The pipeline_name is mandatory for stateful ingestion and the state is tied to this.\n# If this is changed after using with stateful ingestion, the previous state will not be available to the next run.\npipeline_name: "my_snowflake_usage_ingestion_pipeline_1"\nsink:\n  type: "datahub-rest"\n  config:\n    server: \'http://localhost:8080\'\n')),(0,r.kt)("h2",{id:"the-ingestion-state-provider"},"The Ingestion State Provider"),(0,r.kt)("p",null,"The ingestion state provider is responsible for saving and retrieving the ingestion state associated with the ingestion runs\nof various jobs inside the source connector of the ingestion pipeline. An ingestion state provider needs to implement the\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/linkedin/datahub/blob/master/metadata-ingestion/src/datahub/ingestion/api/ingestion_state_provider.py"},"IngestionStateProvider")," interface and\nregister itself with datahub by adding an entry under ",(0,r.kt)("inlineCode",{parentName:"p"},"datahub.ingestion.state_provider.plugins")," key of the entry_points section in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/linkedin/datahub/blob/master/metadata-ingestion/setup.py"},"setup.py")," with its type and implementation class as shown below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'entry_points = {\n    # <snip other keys>"\n    "datahub.ingestion.state_provider.plugins": [\n        "datahub = datahub.ingestion.source.state_provider.datahub_ingestion_state_provider:DatahubIngestionStateProvider",\n    ]\n}\n')),(0,r.kt)("h3",{id:"datahub-ingestion-state-provider"},"Datahub Ingestion State Provider"),(0,r.kt)("p",null,"This is the state provider implementation that is avialble out of the box. It's type is ",(0,r.kt)("inlineCode",{parentName:"p"},"datahub")," and it is implemented on top\nof the ",(0,r.kt)("inlineCode",{parentName:"p"},"datahub_api")," client and the timeseries aspect capabilities of the datahub-backend."),(0,r.kt)("h4",{id:"config-details-1"},"Config details"),(0,r.kt)("p",null,"Note that a ",(0,r.kt)("inlineCode",{parentName:"p"},".")," is used to denote nested fields in the YAML recipe."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"state_provider.type")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datahub")),(0,r.kt)("td",{parentName:"tr",align:null},"The type of the ingestion state provider registered with datahub")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"state_provider.config")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"The ",(0,r.kt)("inlineCode",{parentName:"td"},"datahub_api")," config if set at pipeline level. Otherwise, the default ",(0,r.kt)("inlineCode",{parentName:"td"},"DatahubClientConfig"),". See the ",(0,r.kt)("a",{parentName:"td",href:"https://github.com/linkedin/datahub/blob/master/metadata-ingestion/src/datahub/ingestion/graph/client.py#L19"},"defaults")," here."),(0,r.kt)("td",{parentName:"tr",align:null},"The configuration required for initializing the state provider.")))))}c.isMDXComponent=!0}}]);