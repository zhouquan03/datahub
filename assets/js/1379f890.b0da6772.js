"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[7278],{4137:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return u}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),d=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},m=function(e){var n=d(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=d(t),u=i,h=p["".concat(l,".").concat(u)]||p[u]||c[u]||s;return t?a.createElement(h,r(r({ref:n},m),{},{components:t})):a.createElement(h,r({ref:n},m))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var s=t.length,r=new Array(s);r[0]=p;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var d=2;d<s;d++)r[d]=t[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},754:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return m},default:function(){return p}});var a=t(7462),i=t(3366),s=(t(7294),t(4137)),r=["components"],o={sidebar_position:1,title:"Dataset",sidebar_label:"Dataset",slug:"/generated/metamodel/entities/dataset",custom_edit_url:"https://github.com/linkedin/datahub/blob/master/docs/generated/metamodel/entities/dataset.md"},l="Dataset",d={unversionedId:"docs/generated/metamodel/entities/dataset",id:"docs/generated/metamodel/entities/dataset",isDocsHomePage:!1,title:"Dataset",description:"The dataset entity is one the most important entities in the metadata model. They represent collections of data that are typically represented as Tables or Views in a database (e.g. BigQuery, Snowflake, Redshift etc.), Streams in a stream-processing environment (Kafka, Pulsar etc.), bundles of data found as Files or Folders in data lake systems (S3, ADLS, etc.).",source:"@site/genDocs/docs/generated/metamodel/entities/dataset.md",sourceDirName:"docs/generated/metamodel/entities",slug:"/generated/metamodel/entities/dataset",permalink:"/docs/generated/metamodel/entities/dataset",editUrl:"https://github.com/linkedin/datahub/blob/master/docs/generated/metamodel/entities/dataset.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Dataset",sidebar_label:"Dataset",slug:"/generated/metamodel/entities/dataset",custom_edit_url:"https://github.com/linkedin/datahub/blob/master/docs/generated/metamodel/entities/dataset.md"},sidebar:"overviewSidebar",previous:{title:"Data Platform",permalink:"/docs/generated/metamodel/entities/dataplatform"},next:{title:"DataJob",permalink:"/docs/generated/metamodel/entities/datajob"}},m=[{value:"Identity",id:"identity",children:[],level:2},{value:"Important Capabilities",id:"important-capabilities",children:[{value:"Schemas",id:"schemas",children:[{value:"Field Paths explained",id:"field-paths-explained",children:[],level:4}],level:3},{value:"Tags and Glossary Terms",id:"tags-and-glossary-terms",children:[{value:"Adding Tags or Glossary Terms at the top-level to a dataset",id:"adding-tags-or-glossary-terms-at-the-top-level-to-a-dataset",children:[],level:4},{value:"Adding Tags or Glossary Terms to columns / fields of a dataset",id:"adding-tags-or-glossary-terms-to-columns--fields-of-a-dataset",children:[],level:4}],level:3},{value:"Ownership",id:"ownership",children:[{value:"Adding Owners",id:"adding-owners",children:[],level:4}],level:3},{value:"Fine-grained lineage",id:"fine-grained-lineage",children:[{value:"Querying lineage information",id:"querying-lineage-information",children:[],level:4}],level:3},{value:"Documentation, Links etc.",id:"documentation-links-etc",children:[],level:3}],level:2},{value:"Notable Exceptions",id:"notable-exceptions",children:[],level:2},{value:"Aspects",id:"aspects",children:[{value:"datasetKey",id:"datasetkey",children:[],level:3},{value:"datasetProperties",id:"datasetproperties",children:[],level:3},{value:"editableDatasetProperties",id:"editabledatasetproperties",children:[],level:3},{value:"datasetUpstreamLineage",id:"datasetupstreamlineage",children:[],level:3},{value:"upstreamLineage",id:"upstreamlineage",children:[],level:3},{value:"institutionalMemory",id:"institutionalmemory",children:[],level:3},{value:"ownership",id:"ownership-1",children:[],level:3},{value:"status",id:"status",children:[],level:3},{value:"schemaMetadata",id:"schemametadata",children:[],level:3},{value:"editableSchemaMetadata",id:"editableschemametadata",children:[],level:3},{value:"globalTags",id:"globaltags",children:[],level:3},{value:"glossaryTerms",id:"glossaryterms",children:[],level:3},{value:"browsePaths",id:"browsepaths",children:[],level:3},{value:"dataPlatformInstance",id:"dataplatforminstance",children:[],level:3},{value:"viewProperties",id:"viewproperties",children:[],level:3},{value:"subTypes",id:"subtypes",children:[],level:3},{value:"domains",id:"domains",children:[],level:3},{value:"container",id:"container",children:[],level:3},{value:"deprecation",id:"deprecation",children:[],level:3},{value:"datasetProfile (Timeseries)",id:"datasetprofile-timeseries",children:[],level:3},{value:"datasetUsageStatistics (Timeseries)",id:"datasetusagestatistics-timeseries",children:[],level:3},{value:"operation (Timeseries)",id:"operation-timeseries",children:[],level:3},{value:"assertionRunEvent (Timeseries)",id:"assertionrunevent-timeseries",children:[],level:3},{value:"datasetDeprecation (Deprecated)",id:"datasetdeprecation-deprecated",children:[],level:3}],level:2},{value:"Relationships",id:"relationships",children:[{value:"Incoming",id:"incoming",children:[],level:3}],level:2},{value:"Global Metadata Model",id:"global-metadata-model",children:[],level:2}],c={toc:m};function p(e){var n=e.components,t=(0,i.Z)(e,r);return(0,s.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"dataset"},"Dataset"),(0,s.kt)("p",null,"The dataset entity is one the most important entities in the metadata model. They represent collections of data that are typically represented as Tables or Views in a database (e.g. BigQuery, Snowflake, Redshift etc.), Streams in a stream-processing environment (Kafka, Pulsar etc.), bundles of data found as Files or Folders in data lake systems (S3, ADLS, etc.)."),(0,s.kt)("h2",{id:"identity"},"Identity"),(0,s.kt)("p",null,"Datasets are identified by three pieces of information:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The platform that they belong to: this is the specific data technology that hosts this dataset. Examples are ",(0,s.kt)("inlineCode",{parentName:"li"},"hive"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"bigquery"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"redshift")," etc. See ",(0,s.kt)("a",{parentName:"li",href:"/docs/generated/metamodel/entities/dataplatform"},"dataplatform")," for more details."),(0,s.kt)("li",{parentName:"ul"},"The name of the dataset in the specific platform. Each platform will have a unique way of naming assets within its system. Usually, names are composed by combining the structural elements of the name and separating them by ",(0,s.kt)("inlineCode",{parentName:"li"},"."),". e.g. relational datasets are usually named as ",(0,s.kt)("inlineCode",{parentName:"li"},"<db>.<schema>.<table>"),", except for platforms like MySQL which do not have the concept of a ",(0,s.kt)("inlineCode",{parentName:"li"},"schema"),"; as a result MySQL datasets are named ",(0,s.kt)("inlineCode",{parentName:"li"},"<db>.<table>"),". In cases where the specific platform can have multiple instances (e.g. there are multiple different instances of MySQL databases that have different data assets in them), names can also include instance ids, making the general pattern for a name ",(0,s.kt)("inlineCode",{parentName:"li"},"<platform_instance>.<db>.<schema>.<table>"),". "),(0,s.kt)("li",{parentName:"ul"},"The environment or fabric in which the dataset belongs: this is an additional qualifier available on the identifier, to allow disambiguating datasets that live in Production environments from datasets that live in Non-production environments, such as Staging, QA, etc. The full list of supported environments / fabrics is available in ",(0,s.kt)("a",{parentName:"li",href:"https://raw.githubusercontent.com/linkedin/datahub/master/li-utils/src/main/pegasus/com/linkedin/common/FabricType.pdl"},"FabricType.pdl"),".")),(0,s.kt)("p",null,"An example of a dataset identifier is ",(0,s.kt)("inlineCode",{parentName:"p"},"urn:li:dataset:(urn:li:dataPlatform:redshift,userdb.public.customer_table,PROD)"),"."),(0,s.kt)("h2",{id:"important-capabilities"},"Important Capabilities"),(0,s.kt)("h3",{id:"schemas"},"Schemas"),(0,s.kt)("p",null,"Datasets support flat and nested schemas. Metadata about schemas are contained in the ",(0,s.kt)("inlineCode",{parentName:"p"},"schemaMetadata")," aspect. Schemas are represented as an array of fields, each identified by a specific field path. "),(0,s.kt)("h4",{id:"field-paths-explained"},"Field Paths explained"),(0,s.kt)("p",null,"Fields that are either top-level or expressible unambiguously using a ",(0,s.kt)("inlineCode",{parentName:"p"},".")," based notation can be identified via a v1 path name, whereas fields that are part of a union need further disambiguation using ",(0,s.kt)("inlineCode",{parentName:"p"},"[type=X]")," markers.\nTaking a simple nested schema as described below:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n    "type": "record",\n    "name": "Customer",\n    "fields":[\n        {\n        "type": "record",\n        "name": "address",\n        "fields": [\n            { "name": "zipcode", "type": string}, \n            {"name": "street", "type": string}]\n        }],\n}\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"v1 field path: ",(0,s.kt)("inlineCode",{parentName:"li"},"address.zipcode")),(0,s.kt)("li",{parentName:"ul"},"v2 field path: ",(0,s.kt)("inlineCode",{parentName:"li"},'[version=2.0].[type=struct].address.[type=string].zipcode"'),". More examples and a formal specification of a v2 fieldPath can be found ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/linkedin/datahub/blob/master/docs/generated/metamodel/entities/docs/advanced/field-path-spec-v2/"},"here"),". ")),(0,s.kt)("p",null,"Understanding field paths is important, because they are the identifiers through which tags, terms, documentation on fields are expressed. Besides the type and name of the field, schemas also contain descriptions attached to the individual fields, as well as information about primary and foreign keys."),(0,s.kt)("p",null,"The following code snippet shows you how to add a Schema containing 3 fields to a dataset."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Python SDK: Add a schema to a dataset"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'# inlined from metadata-ingestion/examples/library/dataset_schema.py\n# Imports for urn construction utility methods\nfrom datahub.emitter.mce_builder import make_data_platform_urn, make_dataset_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\n\n# Imports for metadata model classes\nfrom datahub.metadata.schema_classes import (\n    ChangeTypeClass,\n    DateTypeClass,\n    OtherSchemaClass,\n    SchemaFieldClass,\n    SchemaFieldDataTypeClass,\n    SchemaMetadataClass,\n    StringTypeClass,\n)\n\nevent: MetadataChangeProposalWrapper = MetadataChangeProposalWrapper(\n    entityType="dataset",\n    changeType=ChangeTypeClass.UPSERT,\n    entityUrn=make_dataset_urn(platform="hive", name="realestate_db.sales", env="PROD"),\n    aspectName="schemaMetadata",\n    aspect=SchemaMetadataClass(\n        schemaName="customer",  # not used\n        platform=make_data_platform_urn("hive"),  # important <- platform must be an urn\n        version=0,  # when the source system has a notion of versioning of schemas, insert this in, otherwise leave as 0\n        hash="",  # when the source system has a notion of unique schemas identified via hash, include a hash, else leave it as empty string\n        platformSchema=OtherSchemaClass(rawSchema="__insert raw schema here__"),\n        fields=[\n            SchemaFieldClass(\n                fieldPath="address.zipcode",\n                type=SchemaFieldDataTypeClass(type=StringTypeClass()),\n                nativeDataType="VARCHAR(50)",  # use this to provide the type of the field in the source system\'s vernacular\n                description="This is the zipcode of the address. Specified using extended form and limited to addresses in the United States",\n            ),\n            SchemaFieldClass(\n                fieldPath="address.street",\n                type=SchemaFieldDataTypeClass(type=StringTypeClass()),\n                nativeDataType="VARCHAR(100)",\n                description="Street corresponding to the address",\n            ),\n            SchemaFieldClass(\n                fieldPath="last_sold_date",\n                type=SchemaFieldDataTypeClass(type=DateTypeClass()),\n                nativeDataType="Date",\n                description="Date of the last sale date for this property",\n            ),\n        ],\n    ),\n)\n\n# Create rest emitter\nrest_emitter = DatahubRestEmitter(gms_server="http://localhost:8080")\nrest_emitter.emit(event)\n\n'))),(0,s.kt)("h3",{id:"tags-and-glossary-terms"},"Tags and Glossary Terms"),(0,s.kt)("p",null,"Datasets can have Tags or Terms attached to them. Read ",(0,s.kt)("a",{parentName:"p",href:"https://blog.datahubproject.io/tags-and-terms-two-powerful-datahub-features-used-in-two-different-scenarios-b5b4791e892e"},"this blog")," to understand the difference between tags and terms so you understand when you should use which."),(0,s.kt)("h4",{id:"adding-tags-or-glossary-terms-at-the-top-level-to-a-dataset"},"Adding Tags or Glossary Terms at the top-level to a dataset"),(0,s.kt)("p",null,"At the top-level, tags are added to datasets using the ",(0,s.kt)("inlineCode",{parentName:"p"},"globalTags")," aspect, while terms are added using the ",(0,s.kt)("inlineCode",{parentName:"p"},"glossaryTerms")," aspect."),(0,s.kt)("p",null,"Here is an example for how to add a tag to a dataset. Note that this involves reading the currently set tags on the dataset and then adding a new one if needed."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Python SDK: Add a tag to a dataset at the top-level"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'# inlined from metadata-ingestion/examples/library/dataset_add_tag.py\nimport logging\nfrom typing import Optional\n\nfrom datahub.emitter.mce_builder import make_dataset_urn, make_tag_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\n\n# read-modify-write requires access to the DataHubGraph (RestEmitter is not enough)\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\n# Imports for metadata model classes\nfrom datahub.metadata.schema_classes import (\n    ChangeTypeClass,\n    GlobalTagsClass,\n    TagAssociationClass,\n)\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\n\n# First we get the current tags\ngms_endpoint = "http://localhost:8080"\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\ndataset_urn = make_dataset_urn(platform="hive", name="realestate_db.sales", env="PROD")\n\ncurrent_tags: Optional[GlobalTagsClass] = graph.get_aspect(\n    entity_urn=dataset_urn,\n    aspect="globalTags",\n    aspect_type=GlobalTagsClass,\n)\n\ntag_to_add = make_tag_urn("purchase")\ntag_association_to_add = TagAssociationClass(tag=tag_to_add)\n\nneed_write = False\nif current_tags:\n    if tag_to_add not in [x.tag for x in current_tags.tags]:\n        # tags exist, but this tag is not present in the current tags\n        current_tags.tags.append(TagAssociationClass(tag_to_add))\n        need_write = True\nelse:\n    # create a brand new tags aspect\n    current_tags = GlobalTagsClass(tags=[tag_association_to_add])\n    need_write = True\n\nif need_write:\n    event: MetadataChangeProposalWrapper = MetadataChangeProposalWrapper(\n        entityType="dataset",\n        changeType=ChangeTypeClass.UPSERT,\n        entityUrn=dataset_urn,\n        aspectName="globalTags",\n        aspect=current_tags,\n    )\n    graph.emit(event)\n    log.info(f"Tag {tag_to_add} added to dataset {dataset_urn}")\n\nelse:\n    log.info(f"Tag {tag_to_add} already exists, omitting write")\n\n'))),(0,s.kt)("p",null,"Here is an example of adding a term to a dataset. Note that this involves reading the currently set terms on the dataset and then adding a new one if needed."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Python SDK: Add a term to a dataset at the top-level"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'# inlined from metadata-ingestion/examples/library/dataset_add_term.py\nimport logging\nfrom typing import Optional\n\nfrom datahub.emitter.mce_builder import make_dataset_urn, make_term_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\n\n# read-modify-write requires access to the DataHubGraph (RestEmitter is not enough)\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\n# Imports for metadata model classes\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    ChangeTypeClass,\n    GlossaryTermAssociationClass,\n    GlossaryTermsClass,\n)\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\n\n# First we get the current terms\ngms_endpoint = "http://localhost:8080"\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\ndataset_urn = make_dataset_urn(platform="hive", name="realestate_db.sales", env="PROD")\n\ncurrent_terms: Optional[GlossaryTermsClass] = graph.get_aspect(\n    entity_urn=dataset_urn,\n    aspect="glossaryTerms",\n    aspect_type=GlossaryTermsClass,\n)\n\nterm_to_add = make_term_urn("Classification.HighlyConfidential")\nterm_association_to_add = GlossaryTermAssociationClass(urn=term_to_add)\n# an audit stamp that basically says we have no idea when these terms were added to this dataset\n# change the time value to (time.time() * 1000) if you want to specify the current time of running this code as the time\nunknown_audit_stamp = AuditStampClass(time=0, actor="urn:li:corpuser:ingestion")\nneed_write = False\nif current_terms:\n    if term_to_add not in [x.urn for x in current_terms.terms]:\n        # terms exist, but this term is not present in the current terms\n        current_terms.terms.append(term_association_to_add)\n        need_write = True\nelse:\n    # create a brand new terms aspect\n    current_terms = GlossaryTermsClass(\n        terms=[term_association_to_add],\n        auditStamp=unknown_audit_stamp,\n    )\n    need_write = True\n\nif need_write:\n    event: MetadataChangeProposalWrapper = MetadataChangeProposalWrapper(\n        entityType="dataset",\n        changeType=ChangeTypeClass.UPSERT,\n        entityUrn=dataset_urn,\n        aspectName="glossaryTerms",\n        aspect=current_terms,\n    )\n    graph.emit(event)\nelse:\n    log.info(f"Term {term_to_add} already exists, omitting write")\n\n'))),(0,s.kt)("h4",{id:"adding-tags-or-glossary-terms-to-columns--fields-of-a-dataset"},"Adding Tags or Glossary Terms to columns / fields of a dataset"),(0,s.kt)("p",null,"Tags and Terms can also be attached to an individual column (field) of a dataset. These attachments are done via the ",(0,s.kt)("inlineCode",{parentName:"p"},"schemaMetadata")," aspect by ingestion connectors / transformers and via the ",(0,s.kt)("inlineCode",{parentName:"p"},"editableSchemaMetadata")," aspect by the UI.\nThis separation allows the writes from the replication of metadata from the source system to be isolated from the edits made in the UI."),(0,s.kt)("p",null,"Here is an example of how you can add a tag to a field in a dataset using the low-level Python SDK."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Python SDK: Add a tag to a column (field) of a dataset"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'# inlined from metadata-ingestion/examples/library/dataset_add_column_term.py\nimport logging\nimport time\n\nfrom datahub.emitter.mce_builder import make_dataset_urn, make_term_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\n\n# read-modify-write requires access to the DataHubGraph (RestEmitter is not enough)\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\n# Imports for metadata model classes\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    ChangeTypeClass,\n    EditableSchemaFieldInfoClass,\n    EditableSchemaMetadataClass,\n    GlossaryTermAssociationClass,\n    GlossaryTermsClass,\n)\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\n\ndef get_simple_field_path_from_v2_field_path(field_path: str) -> str:\n    """A helper function to extract simple . path notation from the v2 field path"""\n    if field_path.startswith("[version=2.0]"):\n        # this is a v2 field path\n        tokens = [\n            t\n            for t in field_path.split(".")\n            if not (t.startswith("[") or t.endswith("]"))\n        ]\n        path = ".".join(tokens)\n        return path\n    else:\n        # not a v2, we assume this is a simple path\n        return field_path\n\n\n# Inputs -> the column, dataset and the term to set\ncolumn = "address.zipcode"\ndataset_urn = make_dataset_urn(platform="hive", name="realestate_db.sales", env="PROD")\nterm_to_add = make_term_urn("Classification.Location")\n\n\n# First we get the current editable schema metadata\ngms_endpoint = "http://localhost:8080"\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\n\ncurrent_editable_schema_metadata = graph.get_aspect(\n    entity_urn=dataset_urn,\n    aspect="editableSchemaMetadata",\n    aspect_type=EditableSchemaMetadataClass,\n)\n\n\n# Some pre-built objects to help all the conditional pathways\nnow = int(time.time() * 1000)  # milliseconds since epoch\ncurrent_timestamp = AuditStampClass(time=now, actor="urn:li:corpuser:ingestion")\n\nterm_association_to_add = GlossaryTermAssociationClass(urn=term_to_add)\nterm_aspect_to_set = GlossaryTermsClass(\n    terms=[term_association_to_add], auditStamp=current_timestamp\n)\nfield_info_to_set = EditableSchemaFieldInfoClass(\n    fieldPath=column, glossaryTerms=term_aspect_to_set\n)\n\nneed_write = False\nfield_match = False\nif current_editable_schema_metadata:\n    for fieldInfo in current_editable_schema_metadata.editableSchemaFieldInfo:\n        if get_simple_field_path_from_v2_field_path(fieldInfo.fieldPath) == column:\n            # we have some editable schema metadata for this field\n            field_match = True\n            if fieldInfo.glossaryTerms:\n                if term_to_add not in [x.urn for x in fieldInfo.glossaryTerms.terms]:\n                    # this tag is not present\n                    fieldInfo.glossaryTerms.terms.append(term_association_to_add)\n                    need_write = True\n            else:\n                fieldInfo.glossaryTerms = term_aspect_to_set\n                need_write = True\n\n    if not field_match:\n        # this field isn\'t present in the editable schema metadata aspect, add it\n        field_info = field_info_to_set\n        current_editable_schema_metadata.editableSchemaFieldInfo.append(field_info)\n        need_write = True\n\nelse:\n    # create a brand new editable schema metadata aspect\n    current_editable_schema_metadata = EditableSchemaMetadataClass(\n        editableSchemaFieldInfo=[field_info_to_set],\n        created=current_timestamp,\n    )\n    need_write = True\n\nif need_write:\n    event: MetadataChangeProposalWrapper = MetadataChangeProposalWrapper(\n        entityType="dataset",\n        changeType=ChangeTypeClass.UPSERT,\n        entityUrn=dataset_urn,\n        aspectName="editableSchemaMetadata",\n        aspect=current_editable_schema_metadata,\n    )\n    graph.emit(event)\n    log.info(f"Tag {term_to_add} added to column {column} of dataset {dataset_urn}")\n\nelse:\n    log.info(f"Tag {term_to_add} already attached to column {column}, omitting write")\n\n'))),(0,s.kt)("p",null,"Similarly, here is an example of how you would add a term to a field in a dataset using the low-level Python SDK. "),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Python SDK: Add a term to a column (field) of a dataset"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'# inlined from metadata-ingestion/examples/library/dataset_add_column_term.py\nimport logging\nimport time\n\nfrom datahub.emitter.mce_builder import make_dataset_urn, make_term_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\n\n# read-modify-write requires access to the DataHubGraph (RestEmitter is not enough)\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\n# Imports for metadata model classes\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    ChangeTypeClass,\n    EditableSchemaFieldInfoClass,\n    EditableSchemaMetadataClass,\n    GlossaryTermAssociationClass,\n    GlossaryTermsClass,\n)\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\n\ndef get_simple_field_path_from_v2_field_path(field_path: str) -> str:\n    """A helper function to extract simple . path notation from the v2 field path"""\n    if field_path.startswith("[version=2.0]"):\n        # this is a v2 field path\n        tokens = [\n            t\n            for t in field_path.split(".")\n            if not (t.startswith("[") or t.endswith("]"))\n        ]\n        path = ".".join(tokens)\n        return path\n    else:\n        # not a v2, we assume this is a simple path\n        return field_path\n\n\n# Inputs -> the column, dataset and the term to set\ncolumn = "address.zipcode"\ndataset_urn = make_dataset_urn(platform="hive", name="realestate_db.sales", env="PROD")\nterm_to_add = make_term_urn("Classification.Location")\n\n\n# First we get the current editable schema metadata\ngms_endpoint = "http://localhost:8080"\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\n\ncurrent_editable_schema_metadata = graph.get_aspect(\n    entity_urn=dataset_urn,\n    aspect="editableSchemaMetadata",\n    aspect_type=EditableSchemaMetadataClass,\n)\n\n\n# Some pre-built objects to help all the conditional pathways\nnow = int(time.time() * 1000)  # milliseconds since epoch\ncurrent_timestamp = AuditStampClass(time=now, actor="urn:li:corpuser:ingestion")\n\nterm_association_to_add = GlossaryTermAssociationClass(urn=term_to_add)\nterm_aspect_to_set = GlossaryTermsClass(\n    terms=[term_association_to_add], auditStamp=current_timestamp\n)\nfield_info_to_set = EditableSchemaFieldInfoClass(\n    fieldPath=column, glossaryTerms=term_aspect_to_set\n)\n\nneed_write = False\nfield_match = False\nif current_editable_schema_metadata:\n    for fieldInfo in current_editable_schema_metadata.editableSchemaFieldInfo:\n        if get_simple_field_path_from_v2_field_path(fieldInfo.fieldPath) == column:\n            # we have some editable schema metadata for this field\n            field_match = True\n            if fieldInfo.glossaryTerms:\n                if term_to_add not in [x.urn for x in fieldInfo.glossaryTerms.terms]:\n                    # this tag is not present\n                    fieldInfo.glossaryTerms.terms.append(term_association_to_add)\n                    need_write = True\n            else:\n                fieldInfo.glossaryTerms = term_aspect_to_set\n                need_write = True\n\n    if not field_match:\n        # this field isn\'t present in the editable schema metadata aspect, add it\n        field_info = field_info_to_set\n        current_editable_schema_metadata.editableSchemaFieldInfo.append(field_info)\n        need_write = True\n\nelse:\n    # create a brand new editable schema metadata aspect\n    current_editable_schema_metadata = EditableSchemaMetadataClass(\n        editableSchemaFieldInfo=[field_info_to_set],\n        created=current_timestamp,\n    )\n    need_write = True\n\nif need_write:\n    event: MetadataChangeProposalWrapper = MetadataChangeProposalWrapper(\n        entityType="dataset",\n        changeType=ChangeTypeClass.UPSERT,\n        entityUrn=dataset_urn,\n        aspectName="editableSchemaMetadata",\n        aspect=current_editable_schema_metadata,\n    )\n    graph.emit(event)\n    log.info(f"Tag {term_to_add} added to column {column} of dataset {dataset_urn}")\n\nelse:\n    log.info(f"Tag {term_to_add} already attached to column {column}, omitting write")\n\n'))),(0,s.kt)("h3",{id:"ownership"},"Ownership"),(0,s.kt)("p",null,"Ownership is associated to a dataset using the ",(0,s.kt)("inlineCode",{parentName:"p"},"ownership")," aspect. Owners can be of a few different types, ",(0,s.kt)("inlineCode",{parentName:"p"},"DATAOWNER"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"PRODUCER"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"DEVELOPER"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"CONSUMER"),", etc. See ",(0,s.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/linkedin/datahub/master/metadata-models/src/main/pegasus/com/linkedin/common/OwnershipType.pdl"},"OwnershipType.pdl")," for the full list of ownership types and their meanings. Ownership can be inherited from source systems, or additionally added in DataHub using the UI. Ingestion connectors for sources will automatically set owners when the source system supports it."),(0,s.kt)("h4",{id:"adding-owners"},"Adding Owners"),(0,s.kt)("p",null,"The following script shows you how to add an owner to a dataset using the low-level Python SDK."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Python SDK: Add an owner to a dataset"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'# inlined from metadata-ingestion/examples/library/dataset_add_owner.py\nimport logging\nfrom typing import Optional\n\nfrom datahub.emitter.mce_builder import make_dataset_urn, make_user_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\n\n# read-modify-write requires access to the DataHubGraph (RestEmitter is not enough)\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\n# Imports for metadata model classes\nfrom datahub.metadata.schema_classes import (\n    ChangeTypeClass,\n    OwnerClass,\n    OwnershipClass,\n    OwnershipTypeClass,\n)\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\n\n# Inputs -> owner, ownership_type, dataset\nowner_to_add = make_user_urn("jdoe")\nownership_type = OwnershipTypeClass.DATAOWNER\ndataset_urn = make_dataset_urn(platform="hive", name="realestate_db.sales", env="PROD")\n\n# Some objects to help with conditional pathways later\nowner_class_to_add = OwnerClass(owner=owner_to_add, type=ownership_type)\nownership_to_add = OwnershipClass(owners=[owner_class_to_add])\n\n\n# First we get the current owners\ngms_endpoint = "http://localhost:8080"\ngraph = DataHubGraph(DatahubClientConfig(server=gms_endpoint))\n\n\ncurrent_owners: Optional[OwnershipClass] = graph.get_aspect(\n    entity_urn=dataset_urn,\n    aspect="ownership",\n    aspect_type=OwnershipClass,\n)\n\n\nneed_write = False\nif current_owners:\n    if (owner_to_add, ownership_type) not in [\n        (x.owner, x.type) for x in current_owners.owners\n    ]:\n        # owners exist, but this owner is not present in the current owners\n        current_owners.owners.append(owner_class_to_add)\n        need_write = True\nelse:\n    # create a brand new ownership aspect\n    current_owners = ownership_to_add\n    need_write = True\n\nif need_write:\n    event: MetadataChangeProposalWrapper = MetadataChangeProposalWrapper(\n        entityType="dataset",\n        changeType=ChangeTypeClass.UPSERT,\n        entityUrn=dataset_urn,\n        aspectName="ownership",\n        aspect=current_owners,\n    )\n    graph.emit(event)\n    log.info(\n        f"Owner {owner_to_add}, type {ownership_type} added to dataset {dataset_urn}"\n    )\n\nelse:\n    log.info(f"Owner {owner_to_add} already exists, omitting write")\n\n'))),(0,s.kt)("h3",{id:"fine-grained-lineage"},"Fine-grained lineage"),(0,s.kt)("p",null,"Fine-grained lineage at field level can be associated to a dataset in two ways - either directly attached to the ",(0,s.kt)("inlineCode",{parentName:"p"},"upstreamLineage")," aspect of a dataset, or captured as part of the ",(0,s.kt)("inlineCode",{parentName:"p"},"dataJobInputOutput")," aspect of a dataJob."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Python SDK: Add fine-grained lineage to a dataset"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'# inlined from metadata-ingestion/examples/library/lineage_emitter_dataset_finegrained.py\nimport datahub.emitter.mce_builder as builder\nimport json\n\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.com.linkedin.pegasus2avro.dataset import (\n    DatasetLineageType,\n    FineGrainedLineage,\n    FineGrainedLineageDownstreamType,\n    FineGrainedLineageUpstreamType,\n    Upstream,\n    UpstreamLineage   \n)\nfrom datahub.metadata.schema_classes import ChangeTypeClass, DataJobInputOutputClass\n\ndef datasetUrn(tbl):\n    return builder.make_dataset_urn("postgres", tbl)\n\ndef fldUrn(tbl, fld):\n    return builder.make_schema_field_urn(datasetUrn(tbl), fld); \n\n# Lineage of fields in a dataset\n# c1      <-- unknownFunc(bar2.c1, bar4.c1)\n# c2      <-- myfunc(bar3.c2)\n# {c3,c4} <-- unknownFunc(bar2.c2, bar2.c3, bar3.c1)\n# c5      <-- unknownFunc(bar3)\n# {c6,c7} <-- unknownFunc(bar4)\n\n# note that the semantic of the "transformOperation" value is contextual.\n# In above example, it is regarded as some kind of UDF; but it could also be an expression etc.\n\nfineGrainedLineages=[\n        FineGrainedLineage(\n            upstreamType=FineGrainedLineageUpstreamType.FIELD_SET,\n            upstreams=[fldUrn("bar2", "c1"), fldUrn("bar4", "c1")],\n            downstreamType=FineGrainedLineageDownstreamType.FIELD,\n            downstreams=[fldUrn("bar", "c1")]),\n\n        FineGrainedLineage(\n            upstreamType=FineGrainedLineageUpstreamType.FIELD_SET,\n            upstreams=[fldUrn("bar3","c2")],\n            downstreamType=FineGrainedLineageDownstreamType.FIELD,\n            downstreams=[fldUrn("bar", "c2")], \n            confidenceScore = 0.8, transformOperation="myfunc"),\n\n        FineGrainedLineage(\n            upstreamType=FineGrainedLineageUpstreamType.FIELD_SET,\n            upstreams=[fldUrn("bar2","c2"), fldUrn("bar2","c3"), fldUrn("bar3","c1")],\n            downstreamType=FineGrainedLineageDownstreamType.FIELD_SET, \n            downstreams=[fldUrn("bar", "c3"), fldUrn("bar", "c4")], \n            confidenceScore = 0.7),\n\n        FineGrainedLineage(\n            upstreamType=FineGrainedLineageUpstreamType.DATASET,\n            upstreams=[datasetUrn("bar3")],\n            downstreamType=FineGrainedLineageDownstreamType.FIELD, \n            downstreams=[fldUrn("bar", "c5")]),\n\n        FineGrainedLineage(\n            upstreamType=FineGrainedLineageUpstreamType.DATASET,\n            upstreams=[datasetUrn("bar4")],\n            downstreamType=FineGrainedLineageDownstreamType.FIELD_SET, \n            downstreams=[fldUrn("bar", "c6"), fldUrn("bar", "c7")])            \n    ]\n\n\n# this is just to check if any conflicts with existing Upstream, particularly the DownstreamOf relationship\nupstream = Upstream(dataset=datasetUrn("bar2"), type=DatasetLineageType.TRANSFORMED)\n\nfieldLineages = UpstreamLineage(upstreams=[upstream], fineGrainedLineages=fineGrainedLineages)\n\nlineageMcp = MetadataChangeProposalWrapper(\n    entityType="dataset",\n    changeType=ChangeTypeClass.UPSERT,\n    entityUrn=datasetUrn("bar"),\n    aspectName="upstreamLineage",\n    aspect=fieldLineages\n)\n\n# Create an emitter to the GMS REST API.\nemitter = DatahubRestEmitter("http://localhost:8080")\n\n# Emit metadata!\nemitter.emit_mcp(lineageMcp)\n'))),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Python SDK: Add fine-grained lineage to a datajob"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'# inlined from metadata-ingestion/examples/library/lineage_emitter_datajob_finegrained.py\nimport datahub.emitter.mce_builder as builder\nimport json\n\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\nfrom datahub.emitter.rest_emitter import DatahubRestEmitter\nfrom datahub.metadata.com.linkedin.pegasus2avro.dataset import (\n    DatasetLineageType,\n    FineGrainedLineage,\n    FineGrainedLineageDownstreamType,\n    FineGrainedLineageUpstreamType,\n    Upstream,\n    UpstreamLineage   \n)\nfrom datahub.metadata.schema_classes import ChangeTypeClass, DataJobInputOutputClass\n\ndef datasetUrn(tbl):\n    return builder.make_dataset_urn("postgres", tbl)\n\ndef fldUrn(tbl, fld):\n    return builder.make_schema_field_urn(datasetUrn(tbl), fld); \n\n# Lineage of fields output by a job\n# bar.c1          <-- unknownFunc(bar2.c1, bar4.c1)\n# bar.c2          <-- myfunc(bar3.c2)\n# {bar.c3,bar.c4} <-- unknownFunc(bar2.c2, bar2.c3, bar3.c1)\n# bar.c5          <-- unknownFunc(bar3)\n# {bar.c6,bar.c7} <-- unknownFunc(bar4)\n# bar2.c9 has no upstream i.e. its values are somehow created independently within this job.\n\n# Note that the semantic of the "transformOperation" value is contextual.\n# In above example, it is regarded as some kind of UDF; but it could also be an expression etc.\n\nfineGrainedLineages=[\n        FineGrainedLineage(\n            upstreamType=FineGrainedLineageUpstreamType.FIELD_SET,\n            upstreams=[fldUrn("bar2", "c1"), fldUrn("bar4", "c1")],\n            downstreamType=FineGrainedLineageDownstreamType.FIELD,\n            downstreams=[fldUrn("bar", "c1")]),\n\n        FineGrainedLineage(\n            upstreamType=FineGrainedLineageUpstreamType.FIELD_SET,\n            upstreams=[fldUrn("bar3","c2")],\n            downstreamType=FineGrainedLineageDownstreamType.FIELD,\n            downstreams=[fldUrn("bar", "c2")], \n            confidenceScore = 0.8, transformOperation="myfunc"),\n\n        FineGrainedLineage(\n            upstreamType=FineGrainedLineageUpstreamType.FIELD_SET,\n            upstreams=[fldUrn("bar2","c2"), fldUrn("bar2","c3"), fldUrn("bar3","c1")],\n            downstreamType=FineGrainedLineageDownstreamType.FIELD_SET, \n            downstreams=[fldUrn("bar", "c3"), fldUrn("bar", "c4")], \n            confidenceScore = 0.7),\n\n        FineGrainedLineage(\n            upstreamType=FineGrainedLineageUpstreamType.DATASET,\n            upstreams=[datasetUrn("bar3")],\n            downstreamType=FineGrainedLineageDownstreamType.FIELD, \n            downstreams=[fldUrn("bar", "c5")]),\n\n        FineGrainedLineage(\n            upstreamType=FineGrainedLineageUpstreamType.DATASET,\n            upstreams=[datasetUrn("bar4")],\n            downstreamType=FineGrainedLineageDownstreamType.FIELD_SET, \n            downstreams=[fldUrn("bar", "c6"), fldUrn("bar", "c7")]),     \n\n        FineGrainedLineage(\n            upstreamType=FineGrainedLineageUpstreamType.NONE,\n            upstreams=[],\n            downstreamType=FineGrainedLineageDownstreamType.FIELD, \n            downstreams=[fldUrn("bar2", "c9")])                    \n    ]\n\n# The lineage of output col bar.c9 is unknown. So there is no lineage for it above.\n# Note that bar2 is an input as well as an output dataset, but some fields are inputs while other fields are outputs.\n\ndataJobInputOutput = DataJobInputOutputClass(\n    inputDatasets=[datasetUrn("bar2"), datasetUrn("bar3"), datasetUrn("bar4")], \n    outputDatasets=[datasetUrn("bar"), datasetUrn("bar2")], \n    inputDatajobs=None,\n    inputDatasetFields=[fldUrn("bar2","c1"), fldUrn("bar2","c2"), fldUrn("bar2","c3"), \n                        fldUrn("bar3","c1"), fldUrn("bar3","c2"), fldUrn("bar4","c1")],\n    outputDatasetFields=[fldUrn("bar", "c1"), fldUrn("bar", "c2"),fldUrn("bar", "c3"), \n                         fldUrn("bar", "c4"), fldUrn("bar", "c5"),fldUrn("bar", "c6"), \n                         fldUrn("bar", "c7"), fldUrn("bar", "c9"),\n                         fldUrn("bar2", "c9")],\n    fineGrainedLineages=fineGrainedLineages\n    )\n\ndataJobLineageMcp = MetadataChangeProposalWrapper(\n    entityType="dataJob",\n    changeType=ChangeTypeClass.UPSERT,\n    entityUrn=builder.make_data_job_urn("spark", "Flow1", "Task1"),\n    aspectName="dataJobInputOutput",\n    aspect=dataJobInputOutput\n)\n\n# Create an emitter to the GMS REST API.\nemitter = DatahubRestEmitter("http://localhost:8080")\n\n# Emit metadata!\nemitter.emit_mcp(dataJobLineageMcp)\n'))),(0,s.kt)("h4",{id:"querying-lineage-information"},"Querying lineage information"),(0,s.kt)("p",null,"The standard ",(0,s.kt)("a",{parentName:"p",href:"/docs/metadata-service/#retrieving-entities"},"GET APIs to retrive entities")," can be used to fetch the dataset/datajob created by the above example.\nThe response will include the fine-grained lineage information as well."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Fetch entity snapshot, including fine-grained lineages"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"curl 'http://localhost:8080/entities/urn%3Ali%3Adataset%3A(urn%3Ali%3AdataPlatform%3Apostgres,bar,PROD)'\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"curl 'http://localhost:8080/entities/urn%3Ali%3AdataJob%3A(urn%3Ali%3AdataFlow%3A(spark,Flow1,prod),Task1)'\n"))),(0,s.kt)("p",null,"The below queries can be used to find the upstream/downstream datasets/fields of a dataset/datajob."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Find upstream datasets and fields of a dataset"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'curl \'http://localhost:8080/relationships?direction=OUTGOING&urn=urn%3Ali%3Adataset%3A(urn%3Ali%3AdataPlatform%3Apostgres,bar,PROD)&types=DownstreamOf\'\n\n{\n    "start": 0,\n    "count": 9,\n    "relationships": [\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar4,PROD)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar3,PROD)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar3,PROD),c1)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c3)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c2)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar3,PROD),c2)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar4,PROD),c1)"\n        },\n        {\n            "type": "DownstreamOf",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c1)"\n        }\n    ],\n    "total": 9\n}\n'))),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Find the datasets and fields consumed by a datajob i.e. inputs to a datajob"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'curl \'http://localhost:8080/relationships?direction=OUTGOING&urn=urn%3Ali%3AdataJob%3A(urn%3Ali%3AdataFlow%3A(spark,Flow1,prod),Task1)&types=Consumes\'\n\n{\n    "start": 0,\n    "count": 9,\n    "relationships": [\n        {\n            "type": "Consumes",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar4,PROD)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar3,PROD)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar4,PROD),c1)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar3,PROD),c2)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar3,PROD),c1)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c3)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c2)"\n        },\n        {\n            "type": "Consumes",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c1)"\n        }\n    ],\n    "total": 9\n}\n'))),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Find the datasets and fields produced by a datajob i.e. outputs of a datajob"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'curl \'http://localhost:8080/relationships?direction=OUTGOING&urn=urn%3Ali%3AdataJob%3A(urn%3Ali%3AdataFlow%3A(spark,Flow1,prod),Task1)&types=Produces\'\n\n{\n    "start": 0,\n    "count": 11,\n    "relationships": [\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD),c9)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c9)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c7)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c6)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c5)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c4)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c3)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c2)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:schemaField:(urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD),c1)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar2,PROD)"\n        },\n        {\n            "type": "Produces",\n            "entity": "urn:li:dataset:(urn:li:dataPlatform:postgres,bar,PROD)"\n        }\n    ],\n    "total": 11\n}\n'))),(0,s.kt)("h3",{id:"documentation-links-etc"},"Documentation, Links etc."),(0,s.kt)("p",null,"Documentation for Datasets is available via the ",(0,s.kt)("inlineCode",{parentName:"p"},"datasetProperties")," aspect (typically filled out via ingestion connectors when information is already present in the source system) and via the ",(0,s.kt)("inlineCode",{parentName:"p"},"editableDatasetProperties")," aspect (filled out via the UI typically)"),(0,s.kt)("p",null,"Links that contain more knowledge about the dataset (e.g. links to Confluence pages) can be added via the ",(0,s.kt)("inlineCode",{parentName:"p"},"institutionalMemory")," aspect."),(0,s.kt)("p",null,"Here is a simple script that shows you how to add documentation for a dataset including some links to pages using the low-level Python SDK."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Python SDK: Add documentation, links to a dataset"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'# inlined from metadata-ingestion/examples/library/dataset_add_documentation.py\nimport logging\nimport time\n\nfrom datahub.emitter.mce_builder import make_dataset_urn\nfrom datahub.emitter.mcp import MetadataChangeProposalWrapper\n\n# read-modify-write requires access to the DataHubGraph (RestEmitter is not enough)\nfrom datahub.ingestion.graph.client import DatahubClientConfig, DataHubGraph\n\n# Imports for metadata model classes\nfrom datahub.metadata.schema_classes import (\n    AuditStampClass,\n    ChangeTypeClass,\n    EditableDatasetPropertiesClass,\n    InstitutionalMemoryClass,\n    InstitutionalMemoryMetadataClass,\n)\n\nlog = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\n\n# Inputs -> owner, ownership_type, dataset\ndocumentation_to_add = "## The Real Estate Sales Dataset\\nThis is a really important Dataset that contains all the relevant information about sales that have happened organized by address.\\n"\nlink_to_add = "https://wikipedia.com/real_estate"\nlink_description = "This is the definition of what real estate means"\ndataset_urn = make_dataset_urn(platform="hive", name="realestate_db.sales", env="PROD")\n\n# Some helpful variables to fill out objects later\nnow = int(time.time() * 1000)  # milliseconds since epoch\ncurrent_timestamp = AuditStampClass(time=now, actor="urn:li:corpuser:ingestion")\ninstitutional_memory_element = InstitutionalMemoryMetadataClass(\n    url=link_to_add,\n    description=link_description,\n    createStamp=current_timestamp,\n)\n\n\n# First we get the current owners\ngms_endpoint = "http://localhost:8080"\ngraph = DataHubGraph(config=DatahubClientConfig(server=gms_endpoint))\n\ncurrent_editable_properties = graph.get_aspect(\n    entity_urn=dataset_urn,\n    aspect="editableDatasetProperties",\n    aspect_type=EditableDatasetPropertiesClass,\n)\n\nneed_write = False\nif current_editable_properties:\n    if documentation_to_add != current_editable_properties.description:\n        current_editable_properties.description = documentation_to_add\n        need_write = True\nelse:\n    # create a brand new editable dataset properties aspect\n    current_editable_properties = EditableDatasetPropertiesClass(\n        created=current_timestamp, description=documentation_to_add\n    )\n    need_write = True\n\nif need_write:\n    event: MetadataChangeProposalWrapper = MetadataChangeProposalWrapper(\n        entityType="dataset",\n        changeType=ChangeTypeClass.UPSERT,\n        entityUrn=dataset_urn,\n        aspectName="editableDatasetProperties",\n        aspect=current_editable_properties,\n    )\n    graph.emit(event)\n    log.info(f"Documentation added to dataset {dataset_urn}")\n\nelse:\n    log.info("Documentation already exists and is identical, omitting write")\n\n\ncurrent_institutional_memory = graph.get_aspect(\n    entity_urn=dataset_urn,\n    aspect="institutionalMemory",\n    aspect_type=InstitutionalMemoryClass,\n)\n\nneed_write = False\n\nif current_institutional_memory:\n    if link_to_add not in [x.url for x in current_institutional_memory.elements]:\n        current_institutional_memory.elements.append(institutional_memory_element)\n        need_write = True\nelse:\n    # create a brand new institutional memory aspect\n    current_institutional_memory = InstitutionalMemoryClass(\n        elements=[institutional_memory_element]\n    )\n    need_write = True\n\nif need_write:\n    event = MetadataChangeProposalWrapper(\n        entityType="dataset",\n        changeType=ChangeTypeClass.UPSERT,\n        entityUrn=dataset_urn,\n        aspectName="institutionalMemory",\n        aspect=current_institutional_memory,\n    )\n    graph.emit(event)\n    log.info(f"Link {link_to_add} added to dataset {dataset_urn}")\n\nelse:\n    log.info(f"Link {link_to_add} already exists and is identical, omitting write")\n\n'))),(0,s.kt)("h2",{id:"notable-exceptions"},"Notable Exceptions"),(0,s.kt)("p",null,"The following overloaded uses of the Dataset entity exist for convenience, but will likely move to fully modeled entity types in the future. "),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"OpenAPI endpoints: the GET API of OpenAPI endpoints are currently modeled as Datasets, but should really be modeled as a Service/API entity once this is created in the metadata model."),(0,s.kt)("li",{parentName:"ul"},"DataHub's Logical Entities (e.g.. Dataset, Chart, Dashboard) are represented as Datasets, with sub-type Entity. These should really be modeled as Entities in a logical ER model once this is created in the metadata model.")),(0,s.kt)("h2",{id:"aspects"},"Aspects"),(0,s.kt)("h3",{id:"datasetkey"},"datasetKey"),(0,s.kt)("p",null,"Key for a Dataset"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "datasetKey"\n  },\n  "name": "DatasetKey",\n  "namespace": "com.linkedin.metadata.key",\n  "fields": [\n    {\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "platform",\n      "doc": "Data platform urn associated with the dataset"\n    },\n    {\n      "Searchable": {\n        "boostScore": 10.0,\n        "enableAutocomplete": true,\n        "fieldType": "TEXT_PARTIAL"\n      },\n      "type": "string",\n      "name": "name",\n      "doc": "Dataset native name e.g. <db>.<table>, /dir/subdir/<name>, or <name>"\n    },\n    {\n      "Searchable": {\n        "addToFilters": true,\n        "fieldType": "TEXT_PARTIAL",\n        "filterNameOverride": "Environment",\n        "queryByDefault": false\n      },\n      "type": {\n        "type": "enum",\n        "symbolDocs": {\n          "CORP": "Designates corporation fabrics",\n          "DEV": "Designates development fabrics",\n          "EI": "Designates early-integration fabrics",\n          "NON_PROD": "Designates non-production fabrics",\n          "PROD": "Designates production fabrics",\n          "QA": "Designates quality assurance fabrics",\n          "STG": "Designates staging fabrics",\n          "TEST": "Designates testing fabrics",\n          "UAT": "Designates user acceptance testing fabrics"\n        },\n        "name": "FabricType",\n        "namespace": "com.linkedin.common",\n        "symbols": [\n          "DEV",\n          "TEST",\n          "QA",\n          "UAT",\n          "EI",\n          "STG",\n          "NON_PROD",\n          "PROD",\n          "CORP"\n        ],\n        "doc": "Fabric group type"\n      },\n      "name": "origin",\n      "doc": "Fabric type where dataset belongs to or where it was generated."\n    }\n  ],\n  "doc": "Key for a Dataset"\n}\n'))),(0,s.kt)("h3",{id:"datasetproperties"},"datasetProperties"),(0,s.kt)("p",null,"Properties associated with a Dataset"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "datasetProperties"\n  },\n  "name": "DatasetProperties",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "queryByDefault": true\n        }\n      },\n      "type": {\n        "type": "map",\n        "values": "string"\n      },\n      "name": "customProperties",\n      "default": {},\n      "doc": "Custom property bag."\n    },\n    {\n      "java": {\n        "class": "com.linkedin.common.url.Url",\n        "coercerClass": "com.linkedin.common.url.UrlCoercer"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "externalUrl",\n      "default": null,\n      "doc": "URL where the reference exist"\n    },\n    {\n      "Searchable": {\n        "fieldType": "TEXT",\n        "hasValuesFieldName": "hasDescription"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "description",\n      "default": null,\n      "doc": "Documentation of the dataset"\n    },\n    {\n      "java": {\n        "class": "java.net.URI"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "uri",\n      "default": null,\n      "doc": "The abstracted URI such as hdfs:///data/tracking/PageViewEvent, file:///dir/file_name. Uri should not include any environment specific properties. Some datasets might not have a standardized uri, which makes this field optional (i.e. kafka topic)."\n    },\n    {\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "tags",\n      "default": [],\n      "doc": "[Legacy] Unstructured tags for the dataset. Structured tags can be applied via the `GlobalTags` aspect."\n    }\n  ],\n  "doc": "Properties associated with a Dataset"\n}\n'))),(0,s.kt)("h3",{id:"editabledatasetproperties"},"editableDatasetProperties"),(0,s.kt)("p",null,"EditableDatasetProperties stores editable changes made to dataset properties. This separates changes made from\ningestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "editableDatasetProperties"\n  },\n  "name": "EditableDatasetProperties",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "created",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0\n      },\n      "doc": "An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": "com.linkedin.common.AuditStamp",\n      "name": "lastModified",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0\n      },\n      "doc": "An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": [\n        "null",\n        "com.linkedin.common.AuditStamp"\n      ],\n      "name": "deleted",\n      "default": null,\n      "doc": "An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."\n    },\n    {\n      "Searchable": {\n        "fieldName": "editedDescription",\n        "fieldType": "TEXT"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "description",\n      "default": null,\n      "doc": "Documentation of the dataset"\n    }\n  ],\n  "doc": "EditableDatasetProperties stores editable changes made to dataset properties. This separates changes made from\\ningestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines"\n}\n'))),(0,s.kt)("h3",{id:"datasetupstreamlineage"},"datasetUpstreamLineage"),(0,s.kt)("p",null,"Fine Grained upstream lineage for fields in a dataset"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "datasetUpstreamLineage"\n  },\n  "deprecated": "use UpstreamLineage.fineGrainedLineages instead",\n  "name": "DatasetUpstreamLineage",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "deprecated": "use FineGrainedLineage instead",\n          "name": "DatasetFieldMapping",\n          "namespace": "com.linkedin.dataset",\n          "fields": [\n            {\n              "type": {\n                "type": "record",\n                "name": "AuditStamp",\n                "namespace": "com.linkedin.common",\n                "fields": [\n                  {\n                    "type": "long",\n                    "name": "time",\n                    "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": "string",\n                    "name": "actor",\n                    "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "impersonator",\n                    "default": null,\n                    "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                  }\n                ],\n                "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n              },\n              "name": "created",\n              "doc": "Audit stamp containing who reported the field mapping and when"\n            },\n            {\n              "type": [\n                {\n                  "type": "enum",\n                  "symbolDocs": {\n                    "BLACKBOX": "Field transformation expressed as unknown black box function.",\n                    "IDENTITY": "Field transformation expressed as Identity function."\n                  },\n                  "name": "TransformationType",\n                  "namespace": "com.linkedin.common.fieldtransformer",\n                  "symbols": [\n                    "BLACKBOX",\n                    "IDENTITY"\n                  ],\n                  "doc": "Type of the transformation involved in generating destination fields from source fields."\n                },\n                {\n                  "type": "record",\n                  "name": "UDFTransformer",\n                  "namespace": "com.linkedin.common.fieldtransformer",\n                  "fields": [\n                    {\n                      "type": "string",\n                      "name": "udf",\n                      "doc": "A UDF mentioning how the source fields got transformed to destination field. This is the FQCN(Fully Qualified Class Name) of the udf."\n                    }\n                  ],\n                  "doc": "Field transformation expressed in UDF"\n                }\n              ],\n              "name": "transformation",\n              "doc": "Transfomration function between the fields involved"\n            },\n            {\n              "type": {\n                "type": "array",\n                "items": [\n                  "string"\n                ]\n              },\n              "name": "sourceFields",\n              "doc": "Source fields from which the fine grained lineage is derived"\n            },\n            {\n              "deprecated": "use SchemaFieldPath and represent as generic Urn instead",\n              "java": {\n                "class": "com.linkedin.common.urn.DatasetFieldUrn"\n              },\n              "type": "string",\n              "name": "destinationField",\n              "doc": "Destination field which is derived from source fields"\n            }\n          ],\n          "doc": "Representation of mapping between fields in source dataset to the field in destination dataset"\n        }\n      },\n      "name": "fieldMappings",\n      "doc": "Upstream to downstream field level lineage mappings"\n    }\n  ],\n  "doc": "Fine Grained upstream lineage for fields in a dataset"\n}\n'))),(0,s.kt)("h3",{id:"upstreamlineage"},"upstreamLineage"),(0,s.kt)("p",null,"Upstream lineage of a dataset"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "upstreamLineage"\n  },\n  "name": "UpstreamLineage",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "Upstream",\n          "namespace": "com.linkedin.dataset",\n          "fields": [\n            {\n              "deprecated": "we no longer associate a timestamp per upstream edge",\n              "type": {\n                "type": "record",\n                "name": "AuditStamp",\n                "namespace": "com.linkedin.common",\n                "fields": [\n                  {\n                    "type": "long",\n                    "name": "time",\n                    "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": "string",\n                    "name": "actor",\n                    "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "impersonator",\n                    "default": null,\n                    "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                  }\n                ],\n                "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n              },\n              "name": "auditStamp",\n              "default": {\n                "actor": "urn:li:corpuser:unknown",\n                "impersonator": null,\n                "time": 0\n              },\n              "doc": "Audit stamp containing who reported the lineage and when.\\nWARNING: this field is deprecated and may be removed in a future release."\n            },\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "dataset"\n                ],\n                "name": "DownstreamOf"\n              },\n              "Searchable": {\n                "fieldName": "upstreams",\n                "fieldType": "URN",\n                "queryByDefault": false\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.DatasetUrn"\n              },\n              "type": "string",\n              "name": "dataset",\n              "doc": "The upstream dataset the lineage points to"\n            },\n            {\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "COPY": "Direct copy without modification",\n                  "TRANSFORMED": "Transformed data with modification (format or content change)",\n                  "VIEW": "Represents a view defined on the sources e.g. Hive view defined on underlying hive tables or a Hive table pointing to a HDFS dataset or DALI view defined on multiple sources"\n                },\n                "name": "DatasetLineageType",\n                "namespace": "com.linkedin.dataset",\n                "symbols": [\n                  "COPY",\n                  "TRANSFORMED",\n                  "VIEW"\n                ],\n                "doc": "The various types of supported dataset lineage"\n              },\n              "name": "type",\n              "doc": "The type of the lineage"\n            }\n          ],\n          "doc": "Upstream lineage information about a dataset including the source reporting the lineage"\n        }\n      },\n      "name": "upstreams",\n      "doc": "List of upstream dataset lineage information"\n    },\n    {\n      "Relationship": {\n        "/*/upstreams/*": {\n          "entityTypes": [\n            "dataset",\n            "schemaField"\n          ],\n          "name": "DownstreamOf"\n        }\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "FineGrainedLineage",\n            "namespace": "com.linkedin.dataset",\n            "fields": [\n              {\n                "type": {\n                  "type": "enum",\n                  "symbolDocs": {\n                    "DATASET": " Indicates that this lineage is originating from upstream dataset(s)",\n                    "FIELD_SET": " Indicates that this lineage is originating from upstream field(s)",\n                    "NONE": " Indicates that there is no upstream lineage i.e. the downstream field is not a derived field"\n                  },\n                  "name": "FineGrainedLineageUpstreamType",\n                  "namespace": "com.linkedin.dataset",\n                  "symbols": [\n                    "FIELD_SET",\n                    "DATASET",\n                    "NONE"\n                  ],\n                  "doc": "The type of upstream entity in a fine-grained lineage"\n                },\n                "name": "upstreamType",\n                "doc": "The type of upstream entity"\n              },\n              {\n                "type": [\n                  "null",\n                  {\n                    "type": "array",\n                    "items": "string"\n                  }\n                ],\n                "name": "upstreams",\n                "default": null,\n                "doc": "Upstream entities in the lineage"\n              },\n              {\n                "type": {\n                  "type": "enum",\n                  "symbolDocs": {\n                    "FIELD": " Indicates that the lineage is for a single, specific, downstream field",\n                    "FIELD_SET": " Indicates that the lineage is for a set of downstream fields"\n                  },\n                  "name": "FineGrainedLineageDownstreamType",\n                  "namespace": "com.linkedin.dataset",\n                  "symbols": [\n                    "FIELD",\n                    "FIELD_SET"\n                  ],\n                  "doc": "The type of downstream field(s) in a fine-grained lineage"\n                },\n                "name": "downstreamType",\n                "doc": "The type of downstream field(s)"\n              },\n              {\n                "type": [\n                  "null",\n                  {\n                    "type": "array",\n                    "items": "string"\n                  }\n                ],\n                "name": "downstreams",\n                "default": null,\n                "doc": "Downstream fields in the lineage"\n              },\n              {\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "transformOperation",\n                "default": null,\n                "doc": "The transform operation applied to the upstream entities to produce the downstream field(s)"\n              },\n              {\n                "type": "float",\n                "name": "confidenceScore",\n                "default": 1.0,\n                "doc": "The confidence in this lineage between 0 (low confidence) and 1 (high confidence)"\n              }\n            ],\n            "doc": "A fine-grained lineage from upstream fields/datasets to downstream field(s)"\n          }\n        }\n      ],\n      "name": "fineGrainedLineages",\n      "default": null,\n      "doc": " List of fine-grained lineage information, including field-level lineage"\n    }\n  ],\n  "doc": "Upstream lineage of a dataset"\n}\n'))),(0,s.kt)("h3",{id:"institutionalmemory"},"institutionalMemory"),(0,s.kt)("p",null,"Institutional memory of an entity. This is a way to link to relevant documentation and provide description of the documentation. Institutional or tribal knowledge is very important for users to leverage the entity."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "institutionalMemory"\n  },\n  "name": "InstitutionalMemory",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "InstitutionalMemoryMetadata",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "java": {\n                "class": "com.linkedin.common.url.Url",\n                "coercerClass": "com.linkedin.common.url.UrlCoercer"\n              },\n              "type": "string",\n              "name": "url",\n              "doc": "Link to an engineering design document or a wiki page."\n            },\n            {\n              "type": "string",\n              "name": "description",\n              "doc": "Description of the link."\n            },\n            {\n              "type": {\n                "type": "record",\n                "name": "AuditStamp",\n                "namespace": "com.linkedin.common",\n                "fields": [\n                  {\n                    "type": "long",\n                    "name": "time",\n                    "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": "string",\n                    "name": "actor",\n                    "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n                  },\n                  {\n                    "java": {\n                      "class": "com.linkedin.common.urn.Urn"\n                    },\n                    "type": [\n                      "null",\n                      "string"\n                    ],\n                    "name": "impersonator",\n                    "default": null,\n                    "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n                  }\n                ],\n                "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n              },\n              "name": "createStamp",\n              "doc": "Audit stamp associated with creation of this record"\n            }\n          ],\n          "doc": "Metadata corresponding to a record of institutional memory."\n        }\n      },\n      "name": "elements",\n      "doc": "List of records that represent institutional memory of an entity. Each record consists of a link, description, creator and timestamps associated with that record."\n    }\n  ],\n  "doc": "Institutional memory of an entity. This is a way to link to relevant documentation and provide description of the documentation. Institutional or tribal knowledge is very important for users to leverage the entity."\n}\n'))),(0,s.kt)("h3",{id:"ownership-1"},"ownership"),(0,s.kt)("p",null,"Ownership information of an entity."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "ownership"\n  },\n  "name": "Ownership",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "Owner",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "Relationship": {\n                "entityTypes": [\n                  "corpUser",\n                  "corpGroup"\n                ],\n                "name": "OwnedBy"\n              },\n              "Searchable": {\n                "addToFilters": true,\n                "fieldName": "owners",\n                "fieldType": "URN",\n                "filterNameOverride": "Owned By",\n                "hasValuesFieldName": "hasOwners",\n                "queryByDefault": false\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.Urn"\n              },\n              "type": "string",\n              "name": "owner",\n              "doc": "Owner URN, e.g. urn:li:corpuser:ldap, urn:li:corpGroup:group_name, and urn:li:multiProduct:mp_name\\n(Caveat: only corpuser is currently supported in the frontend.)"\n            },\n            {\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "CONSUMER": "A person, group, or service that consumes the data",\n                  "DATAOWNER": "A person or group that is owning the data",\n                  "DELEGATE": "A person or a group that overseas the operation, e.g. a DBA or SRE.",\n                  "DEVELOPER": "A person or group that is in charge of developing the code",\n                  "PRODUCER": "A person, group, or service that produces/generates the data",\n                  "STAKEHOLDER": "A person or a group that has direct business interest"\n                },\n                "name": "OwnershipType",\n                "namespace": "com.linkedin.common",\n                "symbols": [\n                  "DEVELOPER",\n                  "DATAOWNER",\n                  "DELEGATE",\n                  "PRODUCER",\n                  "CONSUMER",\n                  "STAKEHOLDER"\n                ],\n                "doc": "Owner category or owner role"\n              },\n              "name": "type",\n              "doc": "The type of the ownership"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "OwnershipSource",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "enum",\n                        "symbolDocs": {\n                          "AUDIT": "Auditing system or audit logs",\n                          "DATABASE": "Database, e.g. GRANTS table",\n                          "FILE_SYSTEM": "File system, e.g. file/directory owner",\n                          "ISSUE_TRACKING_SYSTEM": "Issue tracking system, e.g. Jira",\n                          "MANUAL": "Manually provided by a user",\n                          "OTHER": "Other sources",\n                          "SERVICE": "Other ownership-like service, e.g. Nuage, ACL service etc",\n                          "SOURCE_CONTROL": "SCM system, e.g. GIT, SVN"\n                        },\n                        "name": "OwnershipSourceType",\n                        "namespace": "com.linkedin.common",\n                        "symbols": [\n                          "AUDIT",\n                          "DATABASE",\n                          "FILE_SYSTEM",\n                          "ISSUE_TRACKING_SYSTEM",\n                          "MANUAL",\n                          "SERVICE",\n                          "SOURCE_CONTROL",\n                          "OTHER"\n                        ]\n                      },\n                      "name": "type",\n                      "doc": "The type of the source"\n                    },\n                    {\n                      "type": [\n                        "null",\n                        "string"\n                      ],\n                      "name": "url",\n                      "default": null,\n                      "doc": "A reference URL for the source"\n                    }\n                  ],\n                  "doc": "Source/provider of the ownership information"\n                }\n              ],\n              "name": "source",\n              "default": null,\n              "doc": "Source information for the ownership"\n            }\n          ],\n          "doc": "Ownership information"\n        }\n      },\n      "name": "owners",\n      "doc": "List of owners of the entity."\n    },\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "lastModified",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0\n      },\n      "doc": "Audit stamp containing who last modified the record and when. A value of 0 in the time field indicates missing data."\n    }\n  ],\n  "doc": "Ownership information of an entity."\n}\n'))),(0,s.kt)("h3",{id:"status"},"status"),(0,s.kt)("p",null,"The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\nThis aspect is used to represent soft deletes conventionally."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "status"\n  },\n  "name": "Status",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN"\n      },\n      "type": "boolean",\n      "name": "removed",\n      "default": false,\n      "doc": "Whether the entity has been removed (soft-deleted)."\n    }\n  ],\n  "doc": "The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.\\nThis aspect is used to represent soft deletes conventionally."\n}\n'))),(0,s.kt)("h3",{id:"schemametadata"},"schemaMetadata"),(0,s.kt)("p",null,"SchemaMetadata to describe metadata related to store schema"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "schemaMetadata"\n  },\n  "name": "SchemaMetadata",\n  "namespace": "com.linkedin.schema",\n  "fields": [\n    {\n      "validate": {\n        "strlen": {\n          "max": 500,\n          "min": 1\n        }\n      },\n      "type": "string",\n      "name": "schemaName",\n      "doc": "Schema name e.g. PageViewEvent, identity.Profile, ams.account_management_tracking"\n    },\n    {\n      "java": {\n        "class": "com.linkedin.common.urn.DataPlatformUrn"\n      },\n      "type": "string",\n      "name": "platform",\n      "doc": "Standardized platform urn where schema is defined. The data platform Urn (urn:li:platform:{platform_name})"\n    },\n    {\n      "type": "long",\n      "name": "version",\n      "doc": "Every change to SchemaMetadata in the resource results in a new version. Version is server assigned. This version is differ from platform native schema version."\n    },\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "created",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0\n      },\n      "doc": "An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": "com.linkedin.common.AuditStamp",\n      "name": "lastModified",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0\n      },\n      "doc": "An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": [\n        "null",\n        "com.linkedin.common.AuditStamp"\n      ],\n      "name": "deleted",\n      "default": null,\n      "doc": "An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."\n    },\n    {\n      "java": {\n        "class": "com.linkedin.common.urn.DatasetUrn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "dataset",\n      "default": null,\n      "doc": "Dataset this schema metadata is associated with."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "cluster",\n      "default": null,\n      "doc": "The cluster this schema metadata resides from"\n    },\n    {\n      "type": "string",\n      "name": "hash",\n      "doc": "the SHA1 hash of the schema content"\n    },\n    {\n      "type": [\n        {\n          "type": "record",\n          "name": "EspressoSchema",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "documentSchema",\n              "doc": "The native espresso document schema."\n            },\n            {\n              "type": "string",\n              "name": "tableSchema",\n              "doc": "The espresso table schema definition."\n            }\n          ],\n          "doc": "Schema text of an espresso table schema."\n        },\n        {\n          "type": "record",\n          "name": "OracleDDL",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "tableSchema",\n              "doc": "The native schema in the dataset\'s platform. This is a human readable (json blob) table schema."\n            }\n          ],\n          "doc": "Schema holder for oracle data definition language that describes an oracle table."\n        },\n        {\n          "type": "record",\n          "name": "MySqlDDL",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "tableSchema",\n              "doc": "The native schema in the dataset\'s platform. This is a human readable (json blob) table schema."\n            }\n          ],\n          "doc": "Schema holder for MySql data definition language that describes an MySql table."\n        },\n        {\n          "type": "record",\n          "name": "PrestoDDL",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "rawSchema",\n              "doc": "The raw schema in the dataset\'s platform. This includes the DDL and the columns extracted from DDL."\n            }\n          ],\n          "doc": "Schema holder for presto data definition language that describes a presto view."\n        },\n        {\n          "type": "record",\n          "name": "KafkaSchema",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "documentSchema",\n              "doc": "The native kafka document schema. This is a human readable avro document schema."\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "keySchema",\n              "default": null,\n              "doc": "The native kafka key schema as retrieved from Schema Registry"\n            }\n          ],\n          "doc": "Schema holder for kafka schema."\n        },\n        {\n          "type": "record",\n          "name": "BinaryJsonSchema",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "schema",\n              "doc": "The native schema text for binary JSON file format."\n            }\n          ],\n          "doc": "Schema text of binary JSON schema."\n        },\n        {\n          "type": "record",\n          "name": "OrcSchema",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "schema",\n              "doc": "The native schema for ORC file format."\n            }\n          ],\n          "doc": "Schema text of an ORC schema."\n        },\n        {\n          "type": "record",\n          "name": "Schemaless",\n          "namespace": "com.linkedin.schema",\n          "fields": [],\n          "doc": "The dataset has no specific schema associated with it"\n        },\n        {\n          "type": "record",\n          "name": "KeyValueSchema",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "keySchema",\n              "doc": "The raw schema for the key in the key-value store."\n            },\n            {\n              "type": "string",\n              "name": "valueSchema",\n              "doc": "The raw schema for the value in the key-value store."\n            }\n          ],\n          "doc": "Schema text of a key-value store schema."\n        },\n        {\n          "type": "record",\n          "name": "OtherSchema",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "rawSchema",\n              "doc": "The native schema in the dataset\'s platform."\n            }\n          ],\n          "doc": "Schema holder for undefined schema types."\n        }\n      ],\n      "name": "platformSchema",\n      "doc": "The native schema in the dataset\'s platform."\n    },\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "SchemaField",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "Searchable": {\n                "fieldName": "fieldPaths",\n                "fieldType": "TEXT"\n              },\n              "type": "string",\n              "name": "fieldPath",\n              "doc": "Flattened name of the field. Field is computed from jsonPath field."\n            },\n            {\n              "Deprecated": true,\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "jsonPath",\n              "default": null,\n              "doc": "Flattened name of a field in JSON Path notation."\n            },\n            {\n              "type": "boolean",\n              "name": "nullable",\n              "default": false,\n              "doc": "Indicates if this field is optional or nullable"\n            },\n            {\n              "Searchable": {\n                "boostScore": 0.1,\n                "fieldName": "fieldDescriptions",\n                "fieldType": "TEXT"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "description",\n              "default": null,\n              "doc": "Description"\n            },\n            {\n              "type": {\n                "type": "record",\n                "name": "SchemaFieldDataType",\n                "namespace": "com.linkedin.schema",\n                "fields": [\n                  {\n                    "type": [\n                      {\n                        "type": "record",\n                        "name": "BooleanType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Boolean field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "FixedType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Fixed field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "StringType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "String field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "BytesType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Bytes field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "NumberType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Number data type: long, integer, short, etc.."\n                      },\n                      {\n                        "type": "record",\n                        "name": "DateType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Date field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "TimeType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Time field type. This should also be used for datetimes."\n                      },\n                      {\n                        "type": "record",\n                        "name": "EnumType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Enum field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "NullType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Null field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "MapType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "keyType",\n                            "default": null,\n                            "doc": "Key type in a map"\n                          },\n                          {\n                            "type": [\n                              "null",\n                              "string"\n                            ],\n                            "name": "valueType",\n                            "default": null,\n                            "doc": "Type of the value in a map"\n                          }\n                        ],\n                        "doc": "Map field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "ArrayType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": [\n                              "null",\n                              {\n                                "type": "array",\n                                "items": "string"\n                              }\n                            ],\n                            "name": "nestedType",\n                            "default": null,\n                            "doc": "List of types this array holds."\n                          }\n                        ],\n                        "doc": "Array field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "UnionType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [\n                          {\n                            "type": [\n                              "null",\n                              {\n                                "type": "array",\n                                "items": "string"\n                              }\n                            ],\n                            "name": "nestedTypes",\n                            "default": null,\n                            "doc": "List of types in union type."\n                          }\n                        ],\n                        "doc": "Union field type."\n                      },\n                      {\n                        "type": "record",\n                        "name": "RecordType",\n                        "namespace": "com.linkedin.schema",\n                        "fields": [],\n                        "doc": "Record field type."\n                      }\n                    ],\n                    "name": "type",\n                    "doc": "Data platform specific types"\n                  }\n                ],\n                "doc": "Schema field data types"\n              },\n              "name": "type",\n              "doc": "Platform independent field type of the field."\n            },\n            {\n              "type": "string",\n              "name": "nativeDataType",\n              "doc": "The native type of the field in the dataset\'s platform as declared by platform schema."\n            },\n            {\n              "type": "boolean",\n              "name": "recursive",\n              "default": false,\n              "doc": "There are use cases when a field in type B references type A. A field in A references field of type B. In such cases, we will mark the first field as recursive."\n            },\n            {\n              "Searchable": {\n                "/tags/*/tag": {\n                  "boostScore": 0.5,\n                  "fieldName": "fieldTags",\n                  "fieldType": "URN"\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "Aspect": {\n                    "name": "globalTags"\n                  },\n                  "name": "GlobalTags",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "array",\n                        "items": {\n                          "type": "record",\n                          "name": "TagAssociation",\n                          "namespace": "com.linkedin.common",\n                          "fields": [\n                            {\n                              "Searchable": {\n                                "addToFilters": true,\n                                "fieldName": "tags",\n                                "fieldType": "URN",\n                                "filterNameOverride": "Tag",\n                                "hasValuesFieldName": "hasTags"\n                              },\n                              "java": {\n                                "class": "com.linkedin.common.urn.TagUrn"\n                              },\n                              "type": "string",\n                              "name": "tag",\n                              "doc": "Urn of the applied tag"\n                            }\n                          ],\n                          "doc": "Properties of an applied tag. For now, just an Urn. In the future we can extend this with other properties, e.g.\\npropagation parameters."\n                        }\n                      },\n                      "name": "tags",\n                      "doc": "Tags associated with a given entity"\n                    }\n                  ],\n                  "doc": "Tag aspect used for applying tags to an entity"\n                }\n              ],\n              "name": "globalTags",\n              "default": null,\n              "doc": "Tags associated with the field"\n            },\n            {\n              "Searchable": {\n                "/terms/*/urn": {\n                  "boostScore": 0.5,\n                  "fieldName": "fieldGlossaryTerms",\n                  "fieldType": "URN"\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "Aspect": {\n                    "name": "glossaryTerms"\n                  },\n                  "name": "GlossaryTerms",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "array",\n                        "items": {\n                          "type": "record",\n                          "name": "GlossaryTermAssociation",\n                          "namespace": "com.linkedin.common",\n                          "fields": [\n                            {\n                              "Searchable": {\n                                "addToFilters": true,\n                                "fieldName": "glossaryTerms",\n                                "fieldType": "URN",\n                                "filterNameOverride": "Glossary Term"\n                              },\n                              "java": {\n                                "class": "com.linkedin.common.urn.GlossaryTermUrn"\n                              },\n                              "type": "string",\n                              "name": "urn",\n                              "doc": "Urn of the applied glossary term"\n                            }\n                          ],\n                          "doc": "Properties of an applied glossary term."\n                        }\n                      },\n                      "name": "terms",\n                      "doc": "The related business terms"\n                    },\n                    {\n                      "type": "com.linkedin.common.AuditStamp",\n                      "name": "auditStamp",\n                      "doc": "Audit stamp containing who reported the related business term"\n                    }\n                  ],\n                  "doc": "Related business terms information"\n                }\n              ],\n              "name": "glossaryTerms",\n              "default": null,\n              "doc": "Glossary terms associated with the field"\n            },\n            {\n              "type": "boolean",\n              "name": "isPartOfKey",\n              "default": false,\n              "doc": "For schema fields that are part of complex keys, set this field to true\\nWe do this to easily distinguish between value and key fields"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "jsonProps",\n              "default": null,\n              "doc": "For schema fields that have other properties that are not modeled explicitly,\\nuse this field to serialize those properties into a JSON string"\n            }\n          ],\n          "doc": "SchemaField to describe metadata related to dataset schema."\n        }\n      },\n      "name": "fields",\n      "doc": "Client provided a list of fields from document schema."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": "string"\n        }\n      ],\n      "name": "primaryKeys",\n      "default": null,\n      "doc": "Client provided list of fields that define primary keys to access record. Field order defines hierarchical espresso keys. Empty lists indicates absence of primary key access patter. Value is a SchemaField@fieldPath."\n    },\n    {\n      "deprecated": "Use foreignKeys instead.",\n      "type": [\n        "null",\n        {\n          "type": "map",\n          "values": {\n            "type": "record",\n            "name": "ForeignKeySpec",\n            "namespace": "com.linkedin.schema",\n            "fields": [\n              {\n                "type": [\n                  {\n                    "type": "record",\n                    "name": "DatasetFieldForeignKey",\n                    "namespace": "com.linkedin.schema",\n                    "fields": [\n                      {\n                        "java": {\n                          "class": "com.linkedin.common.urn.DatasetUrn"\n                        },\n                        "type": "string",\n                        "name": "parentDataset",\n                        "doc": "dataset that stores the resource."\n                      },\n                      {\n                        "type": {\n                          "type": "array",\n                          "items": "string"\n                        },\n                        "name": "currentFieldPaths",\n                        "doc": "List of fields in hosting(current) SchemaMetadata that conform a foreign key. List can contain a single entry or multiple entries if several entries in hosting schema conform a foreign key in a single parent dataset."\n                      },\n                      {\n                        "type": "string",\n                        "name": "parentField",\n                        "doc": "SchemaField@fieldPath that uniquely identify field in parent dataset that this field references."\n                      }\n                    ],\n                    "doc": "For non-urn based foregin keys."\n                  },\n                  {\n                    "type": "record",\n                    "name": "UrnForeignKey",\n                    "namespace": "com.linkedin.schema",\n                    "fields": [\n                      {\n                        "type": "string",\n                        "name": "currentFieldPath",\n                        "doc": "Field in hosting(current) SchemaMetadata."\n                      }\n                    ],\n                    "doc": "If SchemaMetadata fields make any external references and references are of type com.linkedin.common.Urn or any children, this models can be used to mark it."\n                  }\n                ],\n                "name": "foreignKey",\n                "doc": "Foreign key definition in metadata schema."\n              }\n            ],\n            "doc": "Description of a foreign key in a schema."\n          }\n        }\n      ],\n      "name": "foreignKeysSpecs",\n      "default": null,\n      "doc": "Map captures all the references schema makes to external datasets. Map key is ForeignKeySpecName typeref."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "ForeignKeyConstraint",\n            "namespace": "com.linkedin.schema",\n            "fields": [\n              {\n                "type": "string",\n                "name": "name",\n                "doc": "Name of the constraint, likely provided from the source"\n              },\n              {\n                "Relationship": {\n                  "/*": {\n                    "entityTypes": [\n                      "schemaField"\n                    ],\n                    "name": "ForeignKeyTo"\n                  }\n                },\n                "type": {\n                  "type": "array",\n                  "items": "string"\n                },\n                "name": "foreignFields",\n                "doc": "Fields the constraint maps to on the foreign dataset"\n              },\n              {\n                "type": {\n                  "type": "array",\n                  "items": "string"\n                },\n                "name": "sourceFields",\n                "doc": "Fields the constraint maps to on the source dataset"\n              },\n              {\n                "Relationship": {\n                  "entityTypes": [\n                    "dataset"\n                  ],\n                  "name": "ForeignKeyToDataset"\n                },\n                "java": {\n                  "class": "com.linkedin.common.urn.Urn"\n                },\n                "type": "string",\n                "name": "foreignDataset",\n                "doc": "Reference to the foreign dataset for ease of lookup"\n              }\n            ],\n            "doc": "Description of a foreign key constraint in a schema."\n          }\n        }\n      ],\n      "name": "foreignKeys",\n      "default": null,\n      "doc": "List of foreign key constraints for the schema"\n    }\n  ],\n  "doc": "SchemaMetadata to describe metadata related to store schema"\n}\n'))),(0,s.kt)("h3",{id:"editableschemametadata"},"editableSchemaMetadata"),(0,s.kt)("p",null,"EditableSchemaMetadata stores editable changes made to schema metadata. This separates changes made from\ningestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "editableSchemaMetadata"\n  },\n  "name": "EditableSchemaMetadata",\n  "namespace": "com.linkedin.schema",\n  "fields": [\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "created",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0\n      },\n      "doc": "An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": "com.linkedin.common.AuditStamp",\n      "name": "lastModified",\n      "default": {\n        "actor": "urn:li:corpuser:unknown",\n        "impersonator": null,\n        "time": 0\n      },\n      "doc": "An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."\n    },\n    {\n      "type": [\n        "null",\n        "com.linkedin.common.AuditStamp"\n      ],\n      "name": "deleted",\n      "default": null,\n      "doc": "An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."\n    },\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "EditableSchemaFieldInfo",\n          "namespace": "com.linkedin.schema",\n          "fields": [\n            {\n              "type": "string",\n              "name": "fieldPath",\n              "doc": "FieldPath uniquely identifying the SchemaField this metadata is associated with"\n            },\n            {\n              "Searchable": {\n                "boostScore": 0.1,\n                "fieldName": "editedFieldDescriptions",\n                "fieldType": "TEXT"\n              },\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "description",\n              "default": null,\n              "doc": "Description"\n            },\n            {\n              "Searchable": {\n                "/tags/*/tag": {\n                  "boostScore": 0.5,\n                  "fieldName": "editedFieldTags",\n                  "fieldType": "URN"\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "Aspect": {\n                    "name": "globalTags"\n                  },\n                  "name": "GlobalTags",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "array",\n                        "items": {\n                          "type": "record",\n                          "name": "TagAssociation",\n                          "namespace": "com.linkedin.common",\n                          "fields": [\n                            {\n                              "Searchable": {\n                                "addToFilters": true,\n                                "fieldName": "tags",\n                                "fieldType": "URN",\n                                "filterNameOverride": "Tag",\n                                "hasValuesFieldName": "hasTags"\n                              },\n                              "java": {\n                                "class": "com.linkedin.common.urn.TagUrn"\n                              },\n                              "type": "string",\n                              "name": "tag",\n                              "doc": "Urn of the applied tag"\n                            }\n                          ],\n                          "doc": "Properties of an applied tag. For now, just an Urn. In the future we can extend this with other properties, e.g.\\npropagation parameters."\n                        }\n                      },\n                      "name": "tags",\n                      "doc": "Tags associated with a given entity"\n                    }\n                  ],\n                  "doc": "Tag aspect used for applying tags to an entity"\n                }\n              ],\n              "name": "globalTags",\n              "default": null,\n              "doc": "Tags associated with the field"\n            },\n            {\n              "Searchable": {\n                "/terms/*/urn": {\n                  "boostScore": 0.5,\n                  "fieldName": "editedFieldGlossaryTerms",\n                  "fieldType": "URN"\n                }\n              },\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "Aspect": {\n                    "name": "glossaryTerms"\n                  },\n                  "name": "GlossaryTerms",\n                  "namespace": "com.linkedin.common",\n                  "fields": [\n                    {\n                      "type": {\n                        "type": "array",\n                        "items": {\n                          "type": "record",\n                          "name": "GlossaryTermAssociation",\n                          "namespace": "com.linkedin.common",\n                          "fields": [\n                            {\n                              "Searchable": {\n                                "addToFilters": true,\n                                "fieldName": "glossaryTerms",\n                                "fieldType": "URN",\n                                "filterNameOverride": "Glossary Term"\n                              },\n                              "java": {\n                                "class": "com.linkedin.common.urn.GlossaryTermUrn"\n                              },\n                              "type": "string",\n                              "name": "urn",\n                              "doc": "Urn of the applied glossary term"\n                            }\n                          ],\n                          "doc": "Properties of an applied glossary term."\n                        }\n                      },\n                      "name": "terms",\n                      "doc": "The related business terms"\n                    },\n                    {\n                      "type": "com.linkedin.common.AuditStamp",\n                      "name": "auditStamp",\n                      "doc": "Audit stamp containing who reported the related business term"\n                    }\n                  ],\n                  "doc": "Related business terms information"\n                }\n              ],\n              "name": "glossaryTerms",\n              "default": null,\n              "doc": "Glossary terms associated with the field"\n            }\n          ],\n          "doc": "SchemaField to describe metadata related to dataset schema."\n        }\n      },\n      "name": "editableSchemaFieldInfo",\n      "doc": "Client provided a list of fields from document schema."\n    }\n  ],\n  "doc": "EditableSchemaMetadata stores editable changes made to schema metadata. This separates changes made from\\ningestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines."\n}\n'))),(0,s.kt)("h3",{id:"globaltags"},"globalTags"),(0,s.kt)("p",null,"Tag aspect used for applying tags to an entity"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "globalTags"\n  },\n  "name": "GlobalTags",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "TagAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "Searchable": {\n                "addToFilters": true,\n                "fieldName": "tags",\n                "fieldType": "URN",\n                "filterNameOverride": "Tag",\n                "hasValuesFieldName": "hasTags"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.TagUrn"\n              },\n              "type": "string",\n              "name": "tag",\n              "doc": "Urn of the applied tag"\n            }\n          ],\n          "doc": "Properties of an applied tag. For now, just an Urn. In the future we can extend this with other properties, e.g.\\npropagation parameters."\n        }\n      },\n      "name": "tags",\n      "doc": "Tags associated with a given entity"\n    }\n  ],\n  "doc": "Tag aspect used for applying tags to an entity"\n}\n'))),(0,s.kt)("h3",{id:"glossaryterms"},"glossaryTerms"),(0,s.kt)("p",null,"Related business terms information"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "glossaryTerms"\n  },\n  "name": "GlossaryTerms",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": {\n        "type": "array",\n        "items": {\n          "type": "record",\n          "name": "GlossaryTermAssociation",\n          "namespace": "com.linkedin.common",\n          "fields": [\n            {\n              "Searchable": {\n                "addToFilters": true,\n                "fieldName": "glossaryTerms",\n                "fieldType": "URN",\n                "filterNameOverride": "Glossary Term"\n              },\n              "java": {\n                "class": "com.linkedin.common.urn.GlossaryTermUrn"\n              },\n              "type": "string",\n              "name": "urn",\n              "doc": "Urn of the applied glossary term"\n            }\n          ],\n          "doc": "Properties of an applied glossary term."\n        }\n      },\n      "name": "terms",\n      "doc": "The related business terms"\n    },\n    {\n      "type": {\n        "type": "record",\n        "name": "AuditStamp",\n        "namespace": "com.linkedin.common",\n        "fields": [\n          {\n            "type": "long",\n            "name": "time",\n            "doc": "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": "string",\n            "name": "actor",\n            "doc": "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."\n          },\n          {\n            "java": {\n              "class": "com.linkedin.common.urn.Urn"\n            },\n            "type": [\n              "null",\n              "string"\n            ],\n            "name": "impersonator",\n            "default": null,\n            "doc": "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."\n          }\n        ],\n        "doc": "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."\n      },\n      "name": "auditStamp",\n      "doc": "Audit stamp containing who reported the related business term"\n    }\n  ],\n  "doc": "Related business terms information"\n}\n'))),(0,s.kt)("h3",{id:"browsepaths"},"browsePaths"),(0,s.kt)("p",null,"Shared aspect containing Browse Paths to be indexed for an entity."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "browsePaths"\n  },\n  "name": "BrowsePaths",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "fieldName": "browsePaths",\n          "fieldType": "BROWSE_PATH"\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "paths",\n      "doc": "A list of valid browse paths for the entity.\\n\\nBrowse paths are expected to be backslash-separated strings. For example: \'prod/snowflake/datasetName\'"\n    }\n  ],\n  "doc": "Shared aspect containing Browse Paths to be indexed for an entity."\n}\n'))),(0,s.kt)("h3",{id:"dataplatforminstance"},"dataPlatformInstance"),(0,s.kt)("p",null,"The specific instance of the data platform that this entity belongs to"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "dataPlatformInstance"\n  },\n  "name": "DataPlatformInstance",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "addToFilters": true,\n        "fieldType": "URN",\n        "filterNameOverride": "Platform"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "platform",\n      "doc": "Data Platform"\n    },\n    {\n      "Searchable": {\n        "fieldName": "platformInstance",\n        "fieldType": "URN"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "instance",\n      "default": null,\n      "doc": "Instance of the data platform (e.g. db instance)"\n    }\n  ],\n  "doc": "The specific instance of the data platform that this entity belongs to"\n}\n'))),(0,s.kt)("h3",{id:"viewproperties"},"viewProperties"),(0,s.kt)("p",null,"Details about a View.\ne.g. Gets activated when subTypes is view"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "viewProperties"\n  },\n  "name": "ViewProperties",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN",\n        "weightsPerFieldValue": {\n          "true": 0.5\n        }\n      },\n      "type": "boolean",\n      "name": "materialized",\n      "doc": "Whether the view is materialized"\n    },\n    {\n      "type": "string",\n      "name": "viewLogic",\n      "doc": "The view logic"\n    },\n    {\n      "type": "string",\n      "name": "viewLanguage",\n      "doc": "The view logic language / dialect"\n    }\n  ],\n  "doc": "Details about a View. \\ne.g. Gets activated when subTypes is view"\n}\n'))),(0,s.kt)("h3",{id:"subtypes"},"subTypes"),(0,s.kt)("p",null,"Sub Types. Use this aspect to specialize a generic Entity\ne.g. Making a Dataset also be a View or also be a LookerExplore"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "subTypes"\n  },\n  "name": "SubTypes",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "/*": {\n          "addToFilters": true,\n          "fieldType": "KEYWORD",\n          "filterNameOverride": "Sub Type",\n          "queryByDefault": true\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "typeNames",\n      "doc": "The names of the specific types.\\n"\n    }\n  ],\n  "doc": "Sub Types. Use this aspect to specialize a generic Entity\\ne.g. Making a Dataset also be a View or also be a LookerExplore"\n}\n'))),(0,s.kt)("h3",{id:"domains"},"domains"),(0,s.kt)("p",null,"Links from an Asset to its Domains"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "domains"\n  },\n  "name": "Domains",\n  "namespace": "com.linkedin.domain",\n  "fields": [\n    {\n      "Relationship": {\n        "/*": {\n          "entityTypes": [\n            "domain"\n          ],\n          "name": "AssociatedWith"\n        }\n      },\n      "Searchable": {\n        "/*": {\n          "addToFilters": true,\n          "fieldName": "domains",\n          "fieldType": "URN",\n          "filterNameOverride": "Domain",\n          "hasValuesFieldName": "hasDomain"\n        }\n      },\n      "type": {\n        "type": "array",\n        "items": "string"\n      },\n      "name": "domains",\n      "doc": "The Domains attached to an Asset"\n    }\n  ],\n  "doc": "Links from an Asset to its Domains"\n}\n'))),(0,s.kt)("h3",{id:"container"},"container"),(0,s.kt)("p",null,"Link from an asset to its parent container"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "container"\n  },\n  "name": "Container",\n  "namespace": "com.linkedin.container",\n  "fields": [\n    {\n      "Relationship": {\n        "entityTypes": [\n          "container"\n        ],\n        "name": "IsPartOf"\n      },\n      "Searchable": {\n        "addToFilters": true,\n        "fieldName": "container",\n        "fieldType": "URN",\n        "filterNameOverride": "Container"\n      },\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "container",\n      "doc": "The parent container of an asset"\n    }\n  ],\n  "doc": "Link from an asset to its parent container"\n}\n'))),(0,s.kt)("h3",{id:"deprecation"},"deprecation"),(0,s.kt)("p",null,"Deprecation status of an entity"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "deprecation"\n  },\n  "name": "Deprecation",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN",\n        "weightsPerFieldValue": {\n          "true": 0.5\n        }\n      },\n      "type": "boolean",\n      "name": "deprecated",\n      "doc": "Whether the entity is deprecated."\n    },\n    {\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "decommissionTime",\n      "default": null,\n      "doc": "The time user plan to decommission this entity."\n    },\n    {\n      "type": "string",\n      "name": "note",\n      "doc": "Additional information about the entity deprecation plan, such as the wiki, doc, RB."\n    },\n    {\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "actor",\n      "doc": "The user URN which will be credited for modifying this deprecation content."\n    }\n  ],\n  "doc": "Deprecation status of an entity"\n}\n'))),(0,s.kt)("h3",{id:"datasetprofile-timeseries"},"datasetProfile (Timeseries)"),(0,s.kt)("p",null,"Stats corresponding to datasets"),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "datasetProfile",\n    "type": "timeseries"\n  },\n  "name": "DatasetProfile",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "type": "long",\n      "name": "timestampMillis",\n      "doc": "The event timestamp field as epoch at UTC in milli seconds."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "TimeWindowSize",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "CalendarInterval",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "SECOND",\n                  "MINUTE",\n                  "HOUR",\n                  "DAY",\n                  "WEEK",\n                  "MONTH",\n                  "QUARTER",\n                  "YEAR"\n                ]\n              },\n              "name": "unit",\n              "doc": "Interval unit such as minute/hour/day etc."\n            },\n            {\n              "type": "int",\n              "name": "multiple",\n              "default": 1,\n              "doc": "How many units. Defaults to 1."\n            }\n          ],\n          "doc": "Defines the size of a time window."\n        }\n      ],\n      "name": "eventGranularity",\n      "default": null,\n      "doc": "Granularity of the event if applicable"\n    },\n    {\n      "type": [\n        {\n          "type": "record",\n          "name": "PartitionSpec",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "PartitionType",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "FULL_TABLE",\n                  "QUERY",\n                  "PARTITION"\n                ]\n              },\n              "name": "type",\n              "default": "PARTITION"\n            },\n            {\n              "type": "string",\n              "name": "partition",\n              "doc": "String representation of the partition"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "TimeWindow",\n                  "namespace": "com.linkedin.timeseries",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "startTimeMillis",\n                      "doc": "Start time as epoch at UTC."\n                    },\n                    {\n                      "type": "com.linkedin.timeseries.TimeWindowSize",\n                      "name": "length",\n                      "doc": "The length of the window."\n                    }\n                  ]\n                }\n              ],\n              "name": "timePartition",\n              "default": null,\n              "doc": "Time window of the partition if applicable"\n            }\n          ],\n          "doc": "Defines how the data is partitioned"\n        },\n        "null"\n      ],\n      "name": "partitionSpec",\n      "default": {\n        "partition": "FULL_TABLE_SNAPSHOT",\n        "type": "FULL_TABLE",\n        "timePartition": null\n      },\n      "doc": "The optional partition specification."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "messageId",\n      "default": null,\n      "doc": "The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."\n    },\n    {\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "rowCount",\n      "default": null\n    },\n    {\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "columnCount",\n      "default": null\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "DatasetFieldProfile",\n            "namespace": "com.linkedin.dataset",\n            "fields": [\n              {\n                "type": "string",\n                "name": "fieldPath"\n              },\n              {\n                "type": [\n                  "null",\n                  "long"\n                ],\n                "name": "uniqueCount",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "float"\n                ],\n                "name": "uniqueProportion",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "long"\n                ],\n                "name": "nullCount",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "float"\n                ],\n                "name": "nullProportion",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "min",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "max",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "mean",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "median",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "stdev",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  {\n                    "type": "array",\n                    "items": {\n                      "type": "record",\n                      "name": "Quantile",\n                      "namespace": "com.linkedin.dataset",\n                      "fields": [\n                        {\n                          "type": "string",\n                          "name": "quantile"\n                        },\n                        {\n                          "type": "string",\n                          "name": "value"\n                        }\n                      ]\n                    }\n                  }\n                ],\n                "name": "quantiles",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  {\n                    "type": "array",\n                    "items": {\n                      "type": "record",\n                      "name": "ValueFrequency",\n                      "namespace": "com.linkedin.dataset",\n                      "fields": [\n                        {\n                          "type": "string",\n                          "name": "value"\n                        },\n                        {\n                          "type": "long",\n                          "name": "frequency"\n                        }\n                      ]\n                    }\n                  }\n                ],\n                "name": "distinctValueFrequencies",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  {\n                    "type": "record",\n                    "name": "Histogram",\n                    "namespace": "com.linkedin.dataset",\n                    "fields": [\n                      {\n                        "type": {\n                          "type": "array",\n                          "items": "string"\n                        },\n                        "name": "boundaries"\n                      },\n                      {\n                        "type": {\n                          "type": "array",\n                          "items": "float"\n                        },\n                        "name": "heights"\n                      }\n                    ]\n                  }\n                ],\n                "name": "histogram",\n                "default": null\n              },\n              {\n                "type": [\n                  "null",\n                  {\n                    "type": "array",\n                    "items": "string"\n                  }\n                ],\n                "name": "sampleValues",\n                "default": null\n              }\n            ],\n            "doc": "Stats corresponding to fields in a dataset"\n          }\n        }\n      ],\n      "name": "fieldProfiles",\n      "default": null\n    }\n  ],\n  "doc": "Stats corresponding to datasets"\n}\n'))),(0,s.kt)("h3",{id:"datasetusagestatistics-timeseries"},"datasetUsageStatistics (Timeseries)"),(0,s.kt)("p",null,"Stats corresponding to dataset's usage."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "datasetUsageStatistics",\n    "type": "timeseries"\n  },\n  "name": "DatasetUsageStatistics",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "type": "long",\n      "name": "timestampMillis",\n      "doc": "The event timestamp field as epoch at UTC in milli seconds."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "TimeWindowSize",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "CalendarInterval",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "SECOND",\n                  "MINUTE",\n                  "HOUR",\n                  "DAY",\n                  "WEEK",\n                  "MONTH",\n                  "QUARTER",\n                  "YEAR"\n                ]\n              },\n              "name": "unit",\n              "doc": "Interval unit such as minute/hour/day etc."\n            },\n            {\n              "type": "int",\n              "name": "multiple",\n              "default": 1,\n              "doc": "How many units. Defaults to 1."\n            }\n          ],\n          "doc": "Defines the size of a time window."\n        }\n      ],\n      "name": "eventGranularity",\n      "default": null,\n      "doc": "Granularity of the event if applicable"\n    },\n    {\n      "type": [\n        {\n          "type": "record",\n          "name": "PartitionSpec",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "PartitionType",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "FULL_TABLE",\n                  "QUERY",\n                  "PARTITION"\n                ]\n              },\n              "name": "type",\n              "default": "PARTITION"\n            },\n            {\n              "type": "string",\n              "name": "partition",\n              "doc": "String representation of the partition"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "TimeWindow",\n                  "namespace": "com.linkedin.timeseries",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "startTimeMillis",\n                      "doc": "Start time as epoch at UTC."\n                    },\n                    {\n                      "type": "com.linkedin.timeseries.TimeWindowSize",\n                      "name": "length",\n                      "doc": "The length of the window."\n                    }\n                  ]\n                }\n              ],\n              "name": "timePartition",\n              "default": null,\n              "doc": "Time window of the partition if applicable"\n            }\n          ],\n          "doc": "Defines how the data is partitioned"\n        },\n        "null"\n      ],\n      "name": "partitionSpec",\n      "default": {\n        "partition": "FULL_TABLE_SNAPSHOT",\n        "type": "FULL_TABLE",\n        "timePartition": null\n      },\n      "doc": "The optional partition specification."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "messageId",\n      "default": null,\n      "doc": "The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        "int"\n      ],\n      "name": "uniqueUserCount",\n      "default": null,\n      "doc": "Unique user count"\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        "int"\n      ],\n      "name": "totalSqlQueries",\n      "default": null,\n      "doc": "Total SQL query count"\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": "string"\n        }\n      ],\n      "name": "topSqlQueries",\n      "default": null,\n      "doc": "Frequent SQL queries; mostly makes sense for datasets in SQL databases"\n    },\n    {\n      "TimeseriesFieldCollection": {\n        "key": "user"\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "DatasetUserUsageCounts",\n            "namespace": "com.linkedin.dataset",\n            "fields": [\n              {\n                "java": {\n                  "class": "com.linkedin.common.urn.Urn"\n                },\n                "type": "string",\n                "name": "user",\n                "doc": "The unique id of the user."\n              },\n              {\n                "TimeseriesField": {},\n                "type": "int",\n                "name": "count",\n                "doc": "Number of times the dataset has been used by the user."\n              },\n              {\n                "TimeseriesField": {},\n                "type": [\n                  "null",\n                  "string"\n                ],\n                "name": "userEmail",\n                "default": null,\n                "doc": "If user_email is set, we attempt to resolve the user\'s urn upon ingest"\n              }\n            ],\n            "doc": "Records a single user\'s usage counts for a given resource"\n          }\n        }\n      ],\n      "name": "userCounts",\n      "default": null,\n      "doc": "Users within this bucket, with frequency counts"\n    },\n    {\n      "TimeseriesFieldCollection": {\n        "key": "fieldPath"\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": {\n            "type": "record",\n            "name": "DatasetFieldUsageCounts",\n            "namespace": "com.linkedin.dataset",\n            "fields": [\n              {\n                "type": "string",\n                "name": "fieldPath",\n                "doc": "The name of the field."\n              },\n              {\n                "TimeseriesField": {},\n                "type": "int",\n                "name": "count",\n                "doc": "Number of times the field has been used."\n              }\n            ],\n            "doc": "Records field-level usage counts for a given dataset"\n          }\n        }\n      ],\n      "name": "fieldCounts",\n      "default": null,\n      "doc": "Field-level usage stats"\n    }\n  ],\n  "doc": "Stats corresponding to dataset\'s usage."\n}\n'))),(0,s.kt)("h3",{id:"operation-timeseries"},"operation (Timeseries)"),(0,s.kt)("p",null,"Operational info for an entity."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "operation",\n    "type": "timeseries"\n  },\n  "name": "Operation",\n  "namespace": "com.linkedin.common",\n  "fields": [\n    {\n      "type": "long",\n      "name": "timestampMillis",\n      "doc": "The event timestamp field as epoch at UTC in milli seconds."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "TimeWindowSize",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "CalendarInterval",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "SECOND",\n                  "MINUTE",\n                  "HOUR",\n                  "DAY",\n                  "WEEK",\n                  "MONTH",\n                  "QUARTER",\n                  "YEAR"\n                ]\n              },\n              "name": "unit",\n              "doc": "Interval unit such as minute/hour/day etc."\n            },\n            {\n              "type": "int",\n              "name": "multiple",\n              "default": 1,\n              "doc": "How many units. Defaults to 1."\n            }\n          ],\n          "doc": "Defines the size of a time window."\n        }\n      ],\n      "name": "eventGranularity",\n      "default": null,\n      "doc": "Granularity of the event if applicable"\n    },\n    {\n      "type": [\n        {\n          "type": "record",\n          "name": "PartitionSpec",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "PartitionType",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "FULL_TABLE",\n                  "QUERY",\n                  "PARTITION"\n                ]\n              },\n              "name": "type",\n              "default": "PARTITION"\n            },\n            {\n              "type": "string",\n              "name": "partition",\n              "doc": "String representation of the partition"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "TimeWindow",\n                  "namespace": "com.linkedin.timeseries",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "startTimeMillis",\n                      "doc": "Start time as epoch at UTC."\n                    },\n                    {\n                      "type": "com.linkedin.timeseries.TimeWindowSize",\n                      "name": "length",\n                      "doc": "The length of the window."\n                    }\n                  ]\n                }\n              ],\n              "name": "timePartition",\n              "default": null,\n              "doc": "Time window of the partition if applicable"\n            }\n          ],\n          "doc": "Defines how the data is partitioned"\n        },\n        "null"\n      ],\n      "name": "partitionSpec",\n      "default": {\n        "partition": "FULL_TABLE_SNAPSHOT",\n        "type": "FULL_TABLE",\n        "timePartition": null\n      },\n      "doc": "The optional partition specification."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "messageId",\n      "default": null,\n      "doc": "The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."\n    },\n    {\n      "TimeseriesField": {},\n      "type": "long",\n      "name": "lastUpdatedTimestamp",\n      "doc": "When the entity was last updated."\n    },\n    {\n      "TimeseriesField": {},\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "actor",\n      "default": null,\n      "doc": "Actor who issued this operation."\n    },\n    {\n      "TimeseriesField": {},\n      "type": {\n        "type": "enum",\n        "name": "OperationType",\n        "namespace": "com.linkedin.common",\n        "symbols": [\n          "INSERT",\n          "UPDATE",\n          "DELETE",\n          "CREATE",\n          "DROP",\n          "UNKNOWN"\n        ],\n        "doc": "Enum to define the operation type when an entity changes."\n      },\n      "name": "operationType",\n      "doc": "Operation type of change."\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "numAffectedRows",\n      "default": null,\n      "doc": "How many rows were affected by this operation."\n    },\n    {\n      "TimeseriesFieldCollection": {\n        "key": "datasetName"\n      },\n      "type": [\n        "null",\n        {\n          "type": "array",\n          "items": "string"\n        }\n      ],\n      "name": "affectedDatasets",\n      "default": null,\n      "doc": "Which other datasets were affected by this operation."\n    }\n  ],\n  "doc": "Operational info for an entity."\n}\n'))),(0,s.kt)("h3",{id:"assertionrunevent-timeseries"},"assertionRunEvent (Timeseries)"),(0,s.kt)("p",null,"An event representing the current status of evaluating an assertion on a batch.\nAssertionRunEvent should be used for reporting the status of a run as an assertion evaluation progresses."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "assertionRunEvent",\n    "type": "timeseries"\n  },\n  "name": "AssertionRunEvent",\n  "namespace": "com.linkedin.assertion",\n  "fields": [\n    {\n      "type": "long",\n      "name": "timestampMillis",\n      "doc": "The event timestamp field as epoch at UTC in milli seconds."\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "TimeWindowSize",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "CalendarInterval",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "SECOND",\n                  "MINUTE",\n                  "HOUR",\n                  "DAY",\n                  "WEEK",\n                  "MONTH",\n                  "QUARTER",\n                  "YEAR"\n                ]\n              },\n              "name": "unit",\n              "doc": "Interval unit such as minute/hour/day etc."\n            },\n            {\n              "type": "int",\n              "name": "multiple",\n              "default": 1,\n              "doc": "How many units. Defaults to 1."\n            }\n          ],\n          "doc": "Defines the size of a time window."\n        }\n      ],\n      "name": "eventGranularity",\n      "default": null,\n      "doc": "Granularity of the event if applicable"\n    },\n    {\n      "type": [\n        {\n          "type": "record",\n          "name": "PartitionSpec",\n          "namespace": "com.linkedin.timeseries",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "name": "PartitionType",\n                "namespace": "com.linkedin.timeseries",\n                "symbols": [\n                  "FULL_TABLE",\n                  "QUERY",\n                  "PARTITION"\n                ]\n              },\n              "name": "type",\n              "default": "PARTITION"\n            },\n            {\n              "type": "string",\n              "name": "partition",\n              "doc": "String representation of the partition"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "record",\n                  "name": "TimeWindow",\n                  "namespace": "com.linkedin.timeseries",\n                  "fields": [\n                    {\n                      "type": "long",\n                      "name": "startTimeMillis",\n                      "doc": "Start time as epoch at UTC."\n                    },\n                    {\n                      "type": "com.linkedin.timeseries.TimeWindowSize",\n                      "name": "length",\n                      "doc": "The length of the window."\n                    }\n                  ]\n                }\n              ],\n              "name": "timePartition",\n              "default": null,\n              "doc": "Time window of the partition if applicable"\n            }\n          ],\n          "doc": "Defines how the data is partitioned"\n        },\n        "null"\n      ],\n      "name": "partitionSpec",\n      "default": {\n        "partition": "FULL_TABLE_SNAPSHOT",\n        "type": "FULL_TABLE",\n        "timePartition": null\n      },\n      "doc": "The optional partition specification."\n    },\n    {\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "messageId",\n      "default": null,\n      "doc": "The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."\n    },\n    {\n      "type": "string",\n      "name": "runId",\n      "doc": " Native (platform-specific) identifier for this run"\n    },\n    {\n      "TimeseriesField": {},\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "assertionUrn"\n    },\n    {\n      "TimeseriesField": {},\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": "string",\n      "name": "asserteeUrn"\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "BatchSpec",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "Searchable": {\n                "/*": {\n                  "queryByDefault": true\n                }\n              },\n              "type": {\n                "type": "map",\n                "values": "string"\n              },\n              "name": "customProperties",\n              "default": {},\n              "doc": "Custom property bag."\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "nativeBatchId",\n              "default": null,\n              "doc": "The native identifier as specified by the system operating on the batch."\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "query",\n              "default": null,\n              "doc": "A query that identifies a batch of data"\n            },\n            {\n              "type": [\n                "null",\n                "int"\n              ],\n              "name": "limit",\n              "default": null,\n              "doc": "Any limit to the number of rows in the batch, if applied"\n            }\n          ],\n          "doc": "A batch on which certain operations, e.g. data quality evaluation, is done."\n        }\n      ],\n      "name": "batchSpec",\n      "default": null,\n      "doc": "Specification of the batch which this run is evaluating"\n    },\n    {\n      "TimeseriesField": {},\n      "type": {\n        "type": "enum",\n        "symbolDocs": {\n          "COMPLETE": "The Assertion Run has completed"\n        },\n        "name": "AssertionRunStatus",\n        "namespace": "com.linkedin.assertion",\n        "symbols": [\n          "COMPLETE"\n        ]\n      },\n      "name": "status",\n      "doc": "The status of the assertion run as per this timeseries event."\n    },\n    {\n      "TimeseriesField": {},\n      "type": [\n        "null",\n        {\n          "type": "record",\n          "name": "AssertionResult",\n          "namespace": "com.linkedin.assertion",\n          "fields": [\n            {\n              "type": {\n                "type": "enum",\n                "symbolDocs": {\n                  "FAILURE": " The Assertion Failed",\n                  "SUCCESS": " The Assertion Succeeded"\n                },\n                "name": "AssertionResultType",\n                "namespace": "com.linkedin.assertion",\n                "symbols": [\n                  "SUCCESS",\n                  "FAILURE"\n                ]\n              },\n              "name": "type",\n              "doc": " The final result, e.g. either SUCCESS or FAILURE."\n            },\n            {\n              "type": [\n                "null",\n                "long"\n              ],\n              "name": "rowCount",\n              "default": null,\n              "doc": "Number of rows for evaluated batch"\n            },\n            {\n              "type": [\n                "null",\n                "long"\n              ],\n              "name": "missingCount",\n              "default": null,\n              "doc": "Number of rows with missing value for evaluated batch"\n            },\n            {\n              "type": [\n                "null",\n                "long"\n              ],\n              "name": "unexpectedCount",\n              "default": null,\n              "doc": "Number of rows with unexpected value for evaluated batch"\n            },\n            {\n              "type": [\n                "null",\n                "float"\n              ],\n              "name": "actualAggValue",\n              "default": null,\n              "doc": "Observed aggregate value for evaluated batch"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "map",\n                  "values": "string"\n                }\n              ],\n              "name": "nativeResults",\n              "default": null,\n              "doc": "Other results of evaluation"\n            },\n            {\n              "type": [\n                "null",\n                "string"\n              ],\n              "name": "externalUrl",\n              "default": null,\n              "doc": "URL where full results are available"\n            },\n            {\n              "type": [\n                "null",\n                {\n                  "type": "map",\n                  "values": "string"\n                }\n              ],\n              "name": "runtimeContext",\n              "default": null,\n              "doc": "Runtime context for the evaluation"\n            }\n          ]\n        }\n      ],\n      "name": "result",\n      "default": null,\n      "doc": "Results of assertion, present if the status is COMPLETE"\n    },\n    {\n      "type": [\n        "null",\n        {\n          "type": "map",\n          "values": "string"\n        }\n      ],\n      "name": "runtimeContext",\n      "default": null,\n      "doc": "Runtime parameters of evaluation"\n    }\n  ],\n  "doc": "An event representing the current status of evaluating an assertion on a batch.\\nAssertionRunEvent should be used for reporting the status of a run as an assertion evaluation progresses."\n}\n'))),(0,s.kt)("h3",{id:"datasetdeprecation-deprecated"},"datasetDeprecation (Deprecated)"),(0,s.kt)("p",null,"Dataset deprecation status\nDeprecated! This aspect is deprecated in favor of the more-general-purpose 'Deprecation' aspect."),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Schema"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "type": "record",\n  "Aspect": {\n    "name": "datasetDeprecation"\n  },\n  "Deprecated": true,\n  "name": "DatasetDeprecation",\n  "namespace": "com.linkedin.dataset",\n  "fields": [\n    {\n      "Searchable": {\n        "fieldType": "BOOLEAN",\n        "weightsPerFieldValue": {\n          "true": 0.5\n        }\n      },\n      "type": "boolean",\n      "name": "deprecated",\n      "doc": "Whether the dataset is deprecated by owner."\n    },\n    {\n      "type": [\n        "null",\n        "long"\n      ],\n      "name": "decommissionTime",\n      "default": null,\n      "doc": "The time user plan to decommission this dataset."\n    },\n    {\n      "type": "string",\n      "name": "note",\n      "doc": "Additional information about the dataset deprecation plan, such as the wiki, doc, RB."\n    },\n    {\n      "java": {\n        "class": "com.linkedin.common.urn.Urn"\n      },\n      "type": [\n        "null",\n        "string"\n      ],\n      "name": "actor",\n      "default": null,\n      "doc": "The corpuser URN which will be credited for modifying this deprecation content."\n    }\n  ],\n  "doc": "Dataset deprecation status\\nDeprecated! This aspect is deprecated in favor of the more-general-purpose \'Deprecation\' aspect."\n}\n'))),(0,s.kt)("h2",{id:"relationships"},"Relationships"),(0,s.kt)("h3",{id:"incoming"},"Incoming"),(0,s.kt)("p",null,"These are the relationships stored in other entity's aspects"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Consumes"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"DataJob via ",(0,s.kt)("inlineCode",{parentName:"li"},"dataJobInputOutput.inputDatasets")),(0,s.kt)("li",{parentName:"ul"},"Chart via ",(0,s.kt)("inlineCode",{parentName:"li"},"chartInfo.inputs")),(0,s.kt)("li",{parentName:"ul"},"DataProcess via ",(0,s.kt)("inlineCode",{parentName:"li"},"dataProcessInfo.inputs")),(0,s.kt)("li",{parentName:"ul"},"DataProcess via ",(0,s.kt)("inlineCode",{parentName:"li"},"dataProcessInfo.outputs")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Produces"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"DataJob via ",(0,s.kt)("inlineCode",{parentName:"li"},"dataJobInputOutput.outputDatasets")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"ForeignKeyToDataset"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"GlossaryTerm via ",(0,s.kt)("inlineCode",{parentName:"li"},"schemaMetadata.foreignKeys.foreignDataset")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Asserts"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Assertion via ",(0,s.kt)("inlineCode",{parentName:"li"},"assertionInfo.datasetAssertion.datasets")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"DerivedFrom"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"MlPrimaryKey via ",(0,s.kt)("inlineCode",{parentName:"li"},"mlPrimaryKeyProperties.sources")),(0,s.kt)("li",{parentName:"ul"},"MlFeature via ",(0,s.kt)("inlineCode",{parentName:"li"},"mlFeatureProperties.sources"))))),(0,s.kt)("h2",{id:"global-metadata-model"},(0,s.kt)("a",{parentName:"h2",href:"https://github.com/linkedin/datahub/raw/master/docs/imgs/datahub-metadata-model.png"},"Global Metadata Model")),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://github.com/linkedin/datahub/raw/master/docs/imgs/datahub-metadata-model.png",alt:"Global Graph"})))}p.isMDXComponent=!0}}]);